import * as fs from "fs";
import * as path from "path";
import { ScanResult, SecurityIssue, severityOrder } from "../types";

export class MarkdownReporter {
  generateReport(result: ScanResult, outputPath: string): void {
    const markdown = this.buildMarkdown(result);
    const dir = path.dirname(outputPath);
    
    if (\!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    
    fs.writeFileSync(outputPath, markdown, "utf-8");
    console.log(`Markdown report written to: ${outputPath}`);
  }

  private buildMarkdown(result: ScanResult): string {
    const { issues, scannedFiles, scanDuration, timestamp } = result;
    
    const criticalCount = issues.filter((i) => i.severity === "CRITICAL").length;
    const highCount = issues.filter((i) => i.severity === "HIGH").length;
    const mediumCount = issues.filter((i) => i.severity === "MEDIUM").length;
    const lowCount = issues.filter((i) => i.severity === "LOW").length;

    const sortedIssues = [...issues].sort(
      (a, b) => severityOrder[b.severity] - severityOrder[a.severity]
    );

    let md = `# Security Scan Report

## Summary

| Metric | Value |
|--------|-------|
| Scan Date | ${timestamp} |
| Files Scanned | ${scannedFiles} |
| Scan Duration | ${(scanDuration / 1000).toFixed(2)}s |
| Total Issues | ${issues.length} |

## Severity Breakdown

| Severity | Count | Status |
|----------|-------|--------|
| CRITICAL | ${criticalCount} | ${criticalCount > 0 ? "FAIL" : "PASS"} |
| HIGH | ${highCount} | ${highCount > 0 ? "FAIL" : "PASS"} |
| MEDIUM | ${mediumCount} | ${mediumCount > 0 ? "WARN" : "PASS"} |
| LOW | ${lowCount} | ${lowCount > 0 ? "INFO" : "PASS"} |

## Overall Status: ${criticalCount > 0 || highCount > 0 ? "FAILED" : "PASSED"}

`;

    if (sortedIssues.length === 0) {
      md += "\n### No security issues found\!\n";
    } else {
      md += `## Issues (${issues.length})\n\n`;

      const groupedBySeverity = this.groupBy(sortedIssues, "severity");

      for (const [severity, sIssues] of Object.entries(groupedBySeverity)) {
        md += `### ${severity} (${sIssues.length})\n\n`;

        for (const issue of sIssues) {
          md += `#### ${issue.title}\n\n`;
          md += `- **File:** \\n`;
          md += `- **Line:** ${issue.line}\n`;
          md += `- **Scanner:** ${issue.scanner}\n`;
          if (issue.cweId) {
            md += `- **CWE:** ${issue.cweId}\n`;
          }
          md += `- **Description:** ${issue.description}\n`;
          md += `- **Code:**\n\\\\n`;
          md += `- **Recommendation:** ${issue.recommendation}\n\n`;
          md += `---\n\n`;
        }
      }
    }

    md += `\n## Scanner Coverage\n\n`;
    const scannerGroups = this.groupBy(sortedIssues, "scanner");
    for (const [scanner, sIssues] of Object.entries(scannerGroups)) {
      md += `- **${scanner}**: ${sIssues.length} issues\n`;
    }

    md += `\n---\n*Generated by @applyforus/security-agent*\n`;

    return md;
  }

  private groupBy<T>(array: T[], key: keyof T): Record<string, T[]> {
    return array.reduce((result, item) => {
      const group = String(item[key]);
      if (\!result[group]) {
        result[group] = [];
      }
      result[group].push(item);
      return result;
    }, {} as Record<string, T[]>);
  }
}

export const markdownReporter = new MarkdownReporter();
