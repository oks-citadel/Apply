# ============================================================================
# Enhanced Azure DevOps Pipeline for JobPilot AI Platform
# ============================================================================
# Project: https://dev.azure.com/citadelcloudmanagement/ApplyPlatform
# Repo: https://dev.azure.com/citadelcloudmanagement/_git/ApplyPlatform
#
# Features:
# - Variable groups for secrets (Azure Key Vault integration)
# - Separate jobs for each service (auth, ai, web)
# - Docker image building and pushing to Azure Container Registry
# - Database migration steps
# - Blue-green deployment for production
# - Approval gates for production
# - Smoke tests after deployment
# - Rollback procedures

trigger:
  branches:
    include:
      - main
      - develop
  paths:
    exclude:
      - '*.md'
      - 'docs/**'
      - 'infrastructure/azure/**'

pr:
  branches:
    include:
      - main
      - develop

# ============================================================================
# Variable Groups (Configure in Azure DevOps)
# ============================================================================
variables:
  - name: NODE_VERSION
    value: '20'
  - name: PNPM_VERSION
    value: '8.15.0'
  - name: PYTHON_VERSION
    value: '3.11'
  - name: DOCKER_BUILDKIT
    value: '1'
  - name: isMain
    value: $[eq(variables['Build.SourceBranch'], 'refs/heads/main')]
  - name: isDevelop
    value: $[eq(variables['Build.SourceBranch'], 'refs/heads/develop')]

  # Import variable groups based on branch
  - ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/develop') }}:
    - group: dev-secrets
  - ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/main') }}:
    - group: prod-secrets

stages:
  # ============================================================================
  # Stage 1: Build and Validate
  # ============================================================================
  - stage: Build
    displayName: 'Build & Validate'
    jobs:
      # Setup and Install Dependencies
      - job: Setup
        displayName: 'Setup Dependencies'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 0

          - task: NodeTool@0
            displayName: 'Install Node.js'
            inputs:
              versionSpec: $(NODE_VERSION)

          - script: |
              corepack enable
              corepack prepare pnpm@$(PNPM_VERSION) --activate
            displayName: 'Install pnpm'

          - task: Cache@2
            displayName: 'Cache pnpm store'
            inputs:
              key: 'pnpm | "$(Agent.OS)" | pnpm-lock.yaml'
              restoreKeys: |
                pnpm | "$(Agent.OS)"
              path: $(Pipeline.Workspace)/.pnpm-store

          - script: |
              pnpm config set store-dir $(Pipeline.Workspace)/.pnpm-store
              pnpm install --frozen-lockfile
            displayName: 'Install dependencies'

          - publish: $(System.DefaultWorkingDirectory)
            artifact: source
            displayName: 'Publish source'

      # Lint Job
      - job: Lint
        displayName: 'Lint Code'
        dependsOn: Setup
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - download: current
            artifact: source

          - task: NodeTool@0
            inputs:
              versionSpec: $(NODE_VERSION)

          - script: |
              cd $(Pipeline.Workspace)/source
              corepack enable
              corepack prepare pnpm@$(PNPM_VERSION) --activate
              pnpm config set store-dir $(Pipeline.Workspace)/.pnpm-store
              pnpm install --frozen-lockfile
            displayName: 'Install dependencies'

          - script: |
              cd $(Pipeline.Workspace)/source
              pnpm run lint
            displayName: 'Run ESLint'

          - script: |
              cd $(Pipeline.Workspace)/source
              pnpm run format:check
            displayName: 'Check Prettier formatting'

      # Type Check Job
      - job: TypeCheck
        displayName: 'TypeScript Check'
        dependsOn: Setup
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - download: current
            artifact: source

          - task: NodeTool@0
            inputs:
              versionSpec: $(NODE_VERSION)

          - script: |
              cd $(Pipeline.Workspace)/source
              corepack enable
              corepack prepare pnpm@$(PNPM_VERSION) --activate
              pnpm config set store-dir $(Pipeline.Workspace)/.pnpm-store
              pnpm install --frozen-lockfile
            displayName: 'Install dependencies'

          - script: |
              cd $(Pipeline.Workspace)/source
              pnpm run type-check
            displayName: 'Run TypeScript type check'

      # Security Audit Job
      - job: SecurityAudit
        displayName: 'Security Audit'
        dependsOn: Setup
        pool:
          vmImage: 'ubuntu-latest'
        continueOnError: true
        steps:
          - download: current
            artifact: source

          - task: NodeTool@0
            inputs:
              versionSpec: $(NODE_VERSION)

          - script: |
              cd $(Pipeline.Workspace)/source
              corepack enable
              corepack prepare pnpm@$(PNPM_VERSION) --activate
              pnpm audit --audit-level moderate
            displayName: 'Run npm audit'
            continueOnError: true

  # ============================================================================
  # Stage 2: Test
  # ============================================================================
  - stage: Test
    displayName: 'Run Tests'
    dependsOn: Build
    jobs:
      - job: UnitTests
        displayName: 'Unit Tests'
        pool:
          vmImage: 'ubuntu-latest'
        services:
          postgres:
            image: postgres:15-alpine
            ports:
              - 5432:5432
            env:
              POSTGRES_USER: postgres
              POSTGRES_PASSWORD: postgres
              POSTGRES_DB: jobpilot_test
          redis:
            image: redis:7-alpine
            ports:
              - 6379:6379
        steps:
          - checkout: self

          - task: NodeTool@0
            inputs:
              versionSpec: $(NODE_VERSION)

          - script: |
              corepack enable
              corepack prepare pnpm@$(PNPM_VERSION) --activate
              pnpm config set store-dir $(Pipeline.Workspace)/.pnpm-store
              pnpm install --frozen-lockfile
            displayName: 'Install dependencies'

          - script: pnpm run test
            displayName: 'Run unit tests'
            env:
              DATABASE_URL: postgresql://postgres:postgres@localhost:5432/jobpilot_test
              REDIS_URL: redis://localhost:6379
              NODE_ENV: test

          - task: PublishTestResults@2
            displayName: 'Publish test results'
            condition: succeededOrFailed()
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: '**/junit.xml'
              mergeTestResults: true
              failTaskOnFailedTests: true

          - task: PublishCodeCoverageResults@1
            displayName: 'Publish code coverage'
            condition: succeededOrFailed()
            inputs:
              codeCoverageTool: 'Cobertura'
              summaryFileLocation: '$(System.DefaultWorkingDirectory)/coverage/cobertura-coverage.xml'
              reportDirectory: '$(System.DefaultWorkingDirectory)/coverage'

      # Python AI Service Tests
      - job: PythonTests
        displayName: 'Python AI Service Tests'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: UsePythonVersion@0
            inputs:
              versionSpec: $(PYTHON_VERSION)
              addToPath: true

          - script: |
              cd services/ai-service
              pip install -r requirements.txt
              pip install pytest pytest-asyncio pytest-cov
            displayName: 'Install Python dependencies'

          - script: |
              cd services/ai-service
              pytest tests/ --cov=src --cov-report=xml --cov-report=html --junitxml=junit.xml
            displayName: 'Run Python tests'
            continueOnError: true

          - task: PublishTestResults@2
            condition: succeededOrFailed()
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: 'services/ai-service/junit.xml'

  # ============================================================================
  # Stage 3: Build Docker Images
  # ============================================================================
  - stage: BuildDockerImages
    displayName: 'Build Docker Images'
    dependsOn: Test
    jobs:
      # Build Web App Image
      - job: BuildWebApp
        displayName: 'Build Web App Image'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: Docker@2
            displayName: 'Login to ACR'
            inputs:
              command: login
              containerRegistry: $(ACR_SERVICE_CONNECTION)

          - task: Docker@2
            displayName: 'Build and Push Web App Image'
            inputs:
              command: buildAndPush
              repository: web-app
              dockerfile: docker/Dockerfile.node
              containerRegistry: $(ACR_SERVICE_CONNECTION)
              tags: |
                $(Build.BuildId)
                latest
                $(Build.SourceBranchName)-$(Build.BuildId)
              arguments: '--build-arg SERVICE=apps/web --build-arg NODE_ENV=production'

      # Build Auth Service Image
      - job: BuildAuthService
        displayName: 'Build Auth Service Image'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: Docker@2
            displayName: 'Login to ACR'
            inputs:
              command: login
              containerRegistry: $(ACR_SERVICE_CONNECTION)

          - task: Docker@2
            displayName: 'Build and Push Auth Service Image'
            inputs:
              command: buildAndPush
              repository: auth-service
              dockerfile: docker/Dockerfile.node
              containerRegistry: $(ACR_SERVICE_CONNECTION)
              tags: |
                $(Build.BuildId)
                latest
                $(Build.SourceBranchName)-$(Build.BuildId)
              arguments: '--build-arg SERVICE=services/auth-service --build-arg NODE_ENV=production'

      # Build AI Service Image
      - job: BuildAIService
        displayName: 'Build AI Service Image'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: Docker@2
            displayName: 'Login to ACR'
            inputs:
              command: login
              containerRegistry: $(ACR_SERVICE_CONNECTION)

          - task: Docker@2
            displayName: 'Build and Push AI Service Image'
            inputs:
              command: buildAndPush
              repository: ai-service
              dockerfile: docker/Dockerfile.python
              containerRegistry: $(ACR_SERVICE_CONNECTION)
              tags: |
                $(Build.BuildId)
                latest
                $(Build.SourceBranchName)-$(Build.BuildId)

  # ============================================================================
  # Stage 4: Deploy to Development
  # ============================================================================
  - stage: DeployDev
    displayName: 'Deploy to Development'
    dependsOn: BuildDockerImages
    condition: and(succeeded(), eq(variables.isDevelop, true))
    variables:
      - group: dev-secrets
    jobs:
      - deployment: DeployDevEnvironment
        displayName: 'Deploy to Dev'
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'development'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self

                - task: AzureCLI@2
                  displayName: 'Run Database Migrations'
                  inputs:
                    azureSubscription: $(AZURE_SUBSCRIPTION)
                    scriptType: bash
                    scriptLocation: scriptPath
                    scriptPath: scripts/migrate-database.sh
                    arguments: 'dev $(DATABASE_URL)'
                  env:
                    DATABASE_URL: $(DATABASE-URL)

                - task: AzureRmWebAppDeployment@4
                  displayName: 'Deploy Web App'
                  inputs:
                    azureSubscription: $(AZURE_SUBSCRIPTION)
                    appType: webAppContainer
                    WebAppName: $(WEB_APP_NAME)
                    DockerNamespace: $(ACR_LOGIN_SERVER)
                    DockerRepository: web-app
                    DockerImageTag: $(Build.BuildId)

                - task: AzureRmWebAppDeployment@4
                  displayName: 'Deploy Auth Service'
                  inputs:
                    azureSubscription: $(AZURE_SUBSCRIPTION)
                    appType: webAppContainer
                    WebAppName: $(AUTH_SERVICE_NAME)
                    DockerNamespace: $(ACR_LOGIN_SERVER)
                    DockerRepository: auth-service
                    DockerImageTag: $(Build.BuildId)

                - task: AzureRmWebAppDeployment@4
                  displayName: 'Deploy AI Service'
                  inputs:
                    azureSubscription: $(AZURE_SUBSCRIPTION)
                    appType: webAppContainer
                    WebAppName: $(AI_SERVICE_NAME)
                    DockerNamespace: $(ACR_LOGIN_SERVER)
                    DockerRepository: ai-service
                    DockerImageTag: $(Build.BuildId)

                - task: AzureCLI@2
                  displayName: 'Smoke Tests'
                  inputs:
                    azureSubscription: $(AZURE_SUBSCRIPTION)
                    scriptType: bash
                    scriptLocation: scriptPath
                    scriptPath: scripts/smoke-tests.sh
                    arguments: 'dev'

  # ============================================================================
  # Stage 5: Deploy to Staging
  # ============================================================================
  - stage: DeployStaging
    displayName: 'Deploy to Staging'
    dependsOn: BuildDockerImages
    condition: and(succeeded(), eq(variables.isMain, true))
    variables:
      - group: staging-secrets
    jobs:
      - deployment: DeployStagingEnvironment
        displayName: 'Deploy to Staging'
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'staging'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self

                - task: AzureCLI@2
                  displayName: 'Run Database Migrations'
                  inputs:
                    azureSubscription: $(AZURE_SUBSCRIPTION)
                    scriptType: bash
                    scriptLocation: scriptPath
                    scriptPath: scripts/migrate-database.sh
                    arguments: 'staging $(DATABASE_URL)'
                  env:
                    DATABASE_URL: $(DATABASE-URL)

                - task: AzureRmWebAppDeployment@4
                  displayName: 'Deploy Web App to Staging'
                  inputs:
                    azureSubscription: $(AZURE_SUBSCRIPTION)
                    appType: webAppContainer
                    WebAppName: $(WEB_APP_NAME)
                    DockerNamespace: $(ACR_LOGIN_SERVER)
                    DockerRepository: web-app
                    DockerImageTag: $(Build.BuildId)

                - task: AzureRmWebAppDeployment@4
                  displayName: 'Deploy Auth Service to Staging'
                  inputs:
                    azureSubscription: $(AZURE_SUBSCRIPTION)
                    appType: webAppContainer
                    WebAppName: $(AUTH_SERVICE_NAME)
                    DockerNamespace: $(ACR_LOGIN_SERVER)
                    DockerRepository: auth-service
                    DockerImageTag: $(Build.BuildId)

                - task: AzureRmWebAppDeployment@4
                  displayName: 'Deploy AI Service to Staging'
                  inputs:
                    azureSubscription: $(AZURE_SUBSCRIPTION)
                    appType: webAppContainer
                    WebAppName: $(AI_SERVICE_NAME)
                    DockerNamespace: $(ACR_LOGIN_SERVER)
                    DockerRepository: ai-service
                    DockerImageTag: $(Build.BuildId)

                - task: AzureCLI@2
                  displayName: 'Smoke Tests'
                  inputs:
                    azureSubscription: $(AZURE_SUBSCRIPTION)
                    scriptType: bash
                    scriptLocation: scriptPath
                    scriptPath: scripts/smoke-tests.sh
                    arguments: 'staging'

  # ============================================================================
  # Stage 6: Deploy to Production (Blue-Green with Approval)
  # ============================================================================
  - stage: DeployProduction
    displayName: 'Deploy to Production'
    dependsOn: DeployStaging
    condition: and(succeeded(), eq(variables.isMain, true))
    variables:
      - group: prod-secrets
    jobs:
      - deployment: DeployProductionBlueGreen
        displayName: 'Deploy to Production (Blue-Green)'
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'production' # Configure approval gates in Azure DevOps
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self

                # Backup current production state
                - task: AzureCLI@2
                  displayName: 'Backup Current State'
                  inputs:
                    azureSubscription: $(AZURE_SUBSCRIPTION)
                    scriptType: bash
                    scriptLocation: inlineScript
                    inlineScript: |
                      echo "Backing up current production configuration..."
                      mkdir -p $(Build.ArtifactStagingDirectory)/backup

                      # Save current App Service configuration
                      for app in $(WEB_APP_NAME) $(AUTH_SERVICE_NAME) $(AI_SERVICE_NAME); do
                        az webapp config show --name $app --resource-group $(RESOURCE_GROUP) \
                          > $(Build.ArtifactStagingDirectory)/backup/${app}-config.json
                      done

                # Run database migrations
                - task: AzureCLI@2
                  displayName: 'Run Database Migrations'
                  inputs:
                    azureSubscription: $(AZURE_SUBSCRIPTION)
                    scriptType: bash
                    scriptLocation: scriptPath
                    scriptPath: scripts/migrate-database.sh
                    arguments: 'prod $(DATABASE_URL)'
                  env:
                    DATABASE_URL: $(DATABASE-URL)

                # Deploy to staging slot (Green)
                - task: AzureRmWebAppDeployment@4
                  displayName: 'Deploy Web App to Staging Slot'
                  inputs:
                    azureSubscription: $(AZURE_SUBSCRIPTION)
                    appType: webAppContainer
                    WebAppName: $(WEB_APP_NAME)
                    deployToSlotOrASE: true
                    ResourceGroupName: $(RESOURCE_GROUP)
                    SlotName: 'staging'
                    DockerNamespace: $(ACR_LOGIN_SERVER)
                    DockerRepository: web-app
                    DockerImageTag: $(Build.BuildId)

                - task: AzureRmWebAppDeployment@4
                  displayName: 'Deploy Auth Service to Staging Slot'
                  inputs:
                    azureSubscription: $(AZURE_SUBSCRIPTION)
                    appType: webAppContainer
                    WebAppName: $(AUTH_SERVICE_NAME)
                    deployToSlotOrASE: true
                    ResourceGroupName: $(RESOURCE_GROUP)
                    SlotName: 'staging'
                    DockerNamespace: $(ACR_LOGIN_SERVER)
                    DockerRepository: auth-service
                    DockerImageTag: $(Build.BuildId)

                - task: AzureRmWebAppDeployment@4
                  displayName: 'Deploy AI Service to Staging Slot'
                  inputs:
                    azureSubscription: $(AZURE_SUBSCRIPTION)
                    appType: webAppContainer
                    WebAppName: $(AI_SERVICE_NAME)
                    deployToSlotOrASE: true
                    ResourceGroupName: $(RESOURCE_GROUP)
                    SlotName: 'staging'
                    DockerNamespace: $(ACR_LOGIN_SERVER)
                    DockerRepository: ai-service
                    DockerImageTag: $(Build.BuildId)

                # Smoke tests on staging slot
                - task: AzureCLI@2
                  displayName: 'Smoke Tests on Staging Slot'
                  inputs:
                    azureSubscription: $(AZURE_SUBSCRIPTION)
                    scriptType: bash
                    scriptLocation: scriptPath
                    scriptPath: scripts/smoke-tests.sh
                    arguments: 'prod-staging'

                # Swap slots (Blue-Green switch)
                - task: AzureAppServiceManage@0
                  displayName: 'Swap Slots (Blue-Green)'
                  inputs:
                    azureSubscription: $(AZURE_SUBSCRIPTION)
                    WebAppName: $(WEB_APP_NAME)
                    ResourceGroupName: $(RESOURCE_GROUP)
                    SourceSlot: 'staging'
                    SwapWithProduction: true

                - task: AzureAppServiceManage@0
                  displayName: 'Swap Auth Service Slots'
                  inputs:
                    azureSubscription: $(AZURE_SUBSCRIPTION)
                    WebAppName: $(AUTH_SERVICE_NAME)
                    ResourceGroupName: $(RESOURCE_GROUP)
                    SourceSlot: 'staging'
                    SwapWithProduction: true

                - task: AzureAppServiceManage@0
                  displayName: 'Swap AI Service Slots'
                  inputs:
                    azureSubscription: $(AZURE_SUBSCRIPTION)
                    WebAppName: $(AI_SERVICE_NAME)
                    ResourceGroupName: $(RESOURCE_GROUP)
                    SourceSlot: 'staging'
                    SwapWithProduction: true

                # Post-deployment smoke tests
                - task: AzureCLI@2
                  displayName: 'Post-Deployment Smoke Tests'
                  inputs:
                    azureSubscription: $(AZURE_SUBSCRIPTION)
                    scriptType: bash
                    scriptLocation: scriptPath
                    scriptPath: scripts/smoke-tests.sh
                    arguments: 'prod'

            on:
              failure:
                steps:
                  - task: AzureCLI@2
                    displayName: 'Rollback on Failure'
                    inputs:
                      azureSubscription: $(AZURE_SUBSCRIPTION)
                      scriptType: bash
                      scriptLocation: scriptPath
                      scriptPath: scripts/rollback.sh
                      arguments: 'prod'

                  - task: AzureAppServiceManage@0
                    displayName: 'Swap Back to Previous Version'
                    inputs:
                      azureSubscription: $(AZURE_SUBSCRIPTION)
                      WebAppName: $(WEB_APP_NAME)
                      ResourceGroupName: $(RESOURCE_GROUP)
                      SourceSlot: 'staging'
                      SwapWithProduction: true

      # Post-Production Monitoring
      - job: PostProductionMonitoring
        displayName: 'Post-Production Monitoring'
        dependsOn: DeployProductionBlueGreen
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: AzureCLI@2
            displayName: 'Monitor Application Health'
            inputs:
              azureSubscription: $(AZURE_SUBSCRIPTION)
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                echo "Monitoring application health for 5 minutes..."

                for i in {1..10}; do
                  echo "Health check iteration $i/10"

                  # Check App Service health
                  for app in $(WEB_APP_NAME) $(AUTH_SERVICE_NAME) $(AI_SERVICE_NAME); do
                    health=$(az webapp show --name $app --resource-group $(RESOURCE_GROUP) --query state -o tsv)
                    echo "$app health: $health"
                  done

                  sleep 30
                done

                echo "Monitoring complete!"

          - task: AzureCLI@2
            displayName: 'Check Application Insights for Errors'
            inputs:
              azureSubscription: $(AZURE_SUBSCRIPTION)
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                echo "Checking Application Insights for errors in the last 10 minutes..."

                # Query for exceptions
                az monitor app-insights query \
                  --app $(APPINSIGHTS_APP_ID) \
                  --analytics-query "exceptions | where timestamp > ago(10m) | summarize count() by type" \
                  --offset 10m
