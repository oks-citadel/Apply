# ============================================================================
# Helm Deployment Template - ApplyforUs Platform
# ============================================================================
# Reusable template for deploying services to AKS using Helm
# Usage: Import this template in your pipeline and pass required parameters

parameters:
  - name: serviceName
    type: string
    displayName: 'Service name to deploy'

  - name: environment
    type: string
    displayName: 'Target environment (dev/test/prod)'
    values:
      - dev
      - test
      - prod

  - name: namespace
    type: string
    default: 'applyforus'
    displayName: 'Kubernetes namespace'

  - name: helmChartPath
    type: string
    default: 'infrastructure/kubernetes'
    displayName: 'Path to Helm chart'

  - name: imageTag
    type: string
    default: '$(Build.BuildId)'
    displayName: 'Docker image tag to deploy'

  - name: aksServiceConnection
    type: string
    displayName: 'AKS Service Connection name'

  - name: valuesFile
    type: string
    default: ''
    displayName: 'Values file override (optional)'

  - name: timeout
    type: string
    default: '10m'
    displayName: 'Helm deployment timeout'

  - name: enableRollback
    type: boolean
    default: true
    displayName: 'Enable automatic rollback on failure'

steps:
  - task: KubectlInstaller@0
    displayName: 'Install kubectl'
    inputs:
      kubectlVersion: 'latest'

  - task: HelmInstaller@1
    displayName: 'Install Helm'
    inputs:
      helmVersionToInstall: 'latest'

  - task: Kubernetes@1
    displayName: 'Connect to AKS Cluster'
    inputs:
      connectionType: 'Kubernetes Service Connection'
      kubernetesServiceEndpoint: '${{ parameters.aksServiceConnection }}'
      command: 'login'

  - task: Bash@3
    displayName: 'Create Namespace if not exists'
    inputs:
      targetType: 'inline'
      script: |
        kubectl create namespace ${{ parameters.namespace }} --dry-run=client -o yaml | kubectl apply -f -
        kubectl label namespace ${{ parameters.namespace }} environment=${{ parameters.environment }} platform=applyforus --overwrite

  - task: Bash@3
    displayName: 'Create Image Pull Secret'
    inputs:
      targetType: 'inline'
      script: |
        kubectl create secret docker-registry acr-secret \
          --docker-server=$(containerRegistryUrl) \
          --docker-username=$(containerRegistryUsername) \
          --docker-password=$(containerRegistryPassword) \
          --namespace=${{ parameters.namespace }} \
          --dry-run=client -o yaml | kubectl apply -f -
    env:
      containerRegistryUsername: $(containerRegistryUsername)
      containerRegistryPassword: $(containerRegistryPassword)

  - task: HelmDeploy@0
    displayName: 'Helm Upgrade/Install - ${{ parameters.serviceName }}'
    inputs:
      connectionType: 'Kubernetes Service Connection'
      kubernetesServiceConnection: '${{ parameters.aksServiceConnection }}'
      namespace: '${{ parameters.namespace }}'
      command: 'upgrade'
      chartType: 'FilePath'
      chartPath: '${{ parameters.helmChartPath }}'
      releaseName: 'applyforus-${{ parameters.serviceName }}-${{ parameters.environment }}'
      install: true
      waitForExecution: true
      arguments: >
        --timeout ${{ parameters.timeout }}
        --set image.repository=$(containerRegistryUrl)/applyforus-${{ parameters.serviceName }}
        --set image.tag=${{ parameters.imageTag }}
        --set environment=${{ parameters.environment }}
        --set imagePullSecrets[0].name=acr-secret
        ${{ eq(parameters.valuesFile, '') && '' || format('--values {0}', parameters.valuesFile) }}
        ${{ eq(parameters.enableRollback, true) && '--atomic --cleanup-on-fail' || '' }}
        --create-namespace

  - task: Kubernetes@1
    displayName: 'Wait for Deployment Rollout - ${{ parameters.serviceName }}'
    inputs:
      connectionType: 'Kubernetes Service Connection'
      kubernetesServiceEndpoint: '${{ parameters.aksServiceConnection }}'
      namespace: '${{ parameters.namespace }}'
      command: 'rollout'
      arguments: 'status deployment/applyforus-${{ parameters.serviceName }} --timeout=${{ parameters.timeout }}'

  - task: Kubernetes@1
    displayName: 'Get Deployment Status - ${{ parameters.serviceName }}'
    inputs:
      connectionType: 'Kubernetes Service Connection'
      kubernetesServiceEndpoint: '${{ parameters.aksServiceConnection }}'
      namespace: '${{ parameters.namespace }}'
      command: 'get'
      arguments: 'deployment applyforus-${{ parameters.serviceName }} -o wide'

  - task: Kubernetes@1
    displayName: 'Get Pods Status - ${{ parameters.serviceName }}'
    inputs:
      connectionType: 'Kubernetes Service Connection'
      kubernetesServiceEndpoint: '${{ parameters.aksServiceConnection }}'
      namespace: '${{ parameters.namespace }}'
      command: 'get'
      arguments: 'pods -l app=applyforus-${{ parameters.serviceName }} -o wide'

  - task: Bash@3
    displayName: 'Health Check - ${{ parameters.serviceName }}'
    inputs:
      targetType: 'inline'
      script: |
        echo "Performing health check for ${{ parameters.serviceName }}..."

        # Get service endpoint
        SERVICE_IP=$(kubectl get svc applyforus-${{ parameters.serviceName }} -n ${{ parameters.namespace }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")

        if [ -z "$SERVICE_IP" ]; then
          echo "Service is using ClusterIP, checking pod health..."
          POD_NAME=$(kubectl get pods -n ${{ parameters.namespace }} -l app=applyforus-${{ parameters.serviceName }} -o jsonpath='{.items[0].metadata.name}')
          kubectl exec -n ${{ parameters.namespace }} $POD_NAME -- wget --spider --timeout=5 http://localhost:3000/health 2>&1
        else
          echo "Service external IP: $SERVICE_IP"
          curl -f -m 10 http://$SERVICE_IP/health || echo "Health check endpoint not available"
        fi

        echo "Deployment completed successfully!"
    continueOnError: true

  - task: PublishPipelineArtifact@1
    displayName: 'Publish Deployment Manifest'
    inputs:
      targetPath: '$(System.DefaultWorkingDirectory)/deployment-manifest.yaml'
      artifactName: 'deployment-manifest-${{ parameters.serviceName }}-${{ parameters.environment }}'
      publishLocation: 'pipeline'
    condition: succeededOrFailed()
