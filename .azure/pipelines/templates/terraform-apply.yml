# ============================================================================
# Terraform Apply Template - ApplyforUs Platform
# ============================================================================
# Reusable template for applying Terraform changes
# Usage: Import this template in your pipeline and pass required parameters

parameters:
  - name: environment
    type: string
    displayName: 'Target environment (dev/test/prod)'
    values:
      - dev
      - test
      - prod

  - name: terraformVersion
    type: string
    default: '1.6.0'
    displayName: 'Terraform version'

  - name: workingDirectory
    type: string
    default: 'infrastructure/terraform'
    displayName: 'Terraform working directory'

  - name: azureServiceConnection
    type: string
    displayName: 'Azure Service Connection'

  - name: backendResourceGroup
    type: string
    displayName: 'Backend storage resource group'

  - name: backendStorageAccount
    type: string
    displayName: 'Backend storage account'

  - name: backendContainerName
    type: string
    default: 'tfstate'
    displayName: 'Backend storage container'

  - name: autoApprove
    type: boolean
    default: false
    displayName: 'Auto-approve (skip manual approval)'

steps:
  - task: DownloadPipelineArtifact@2
    displayName: 'Download Terraform Plan'
    inputs:
      artifactName: 'terraform-plan-${{ parameters.environment }}'
      targetPath: '${{ parameters.workingDirectory }}'

  - task: Bash@3
    displayName: 'Install Terraform'
    inputs:
      targetType: 'inline'
      script: |
        echo "Installing Terraform ${{ parameters.terraformVersion }}..."
        TF_VERSION="${{ parameters.terraformVersion }}"
        if [ "$TF_VERSION" = "latest" ]; then
          TF_VERSION="1.6.0"
        fi
        wget -q https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip
        unzip -o terraform_${TF_VERSION}_linux_amd64.zip
        sudo mv terraform /usr/local/bin/
        terraform version

  - task: AzureCLI@2
    displayName: 'Terraform Init'
    inputs:
      azureSubscription: '${{ parameters.azureServiceConnection }}'
      scriptType: 'bash'
      scriptLocation: 'inlineScript'
      workingDirectory: '${{ parameters.workingDirectory }}'
      inlineScript: |
        # Get storage account key
        ACCOUNT_KEY=$(az storage account keys list \
          --resource-group ${{ parameters.backendResourceGroup }} \
          --account-name ${{ parameters.backendStorageAccount }} \
          --query '[0].value' -o tsv)

        terraform init \
          -backend-config="resource_group_name=${{ parameters.backendResourceGroup }}" \
          -backend-config="storage_account_name=${{ parameters.backendStorageAccount }}" \
          -backend-config="container_name=${{ parameters.backendContainerName }}" \
          -backend-config="key=applyforus-${{ parameters.environment }}.tfstate" \
          -backend-config="access_key=$ACCOUNT_KEY"

  - ${{ if eq(parameters.autoApprove, false) }}:
    - task: ManualValidation@0
      displayName: 'Manual Approval Required'
      inputs:
        notifyUsers: ''
        instructions: 'Review the Terraform plan and approve to proceed with infrastructure changes for ${{ parameters.environment }} environment.'
        onTimeout: 'reject'

  - task: Bash@3
    displayName: 'Backup Current State'
    inputs:
      targetType: 'inline'
      workingDirectory: '${{ parameters.workingDirectory }}'
      script: |
        TIMESTAMP=$(date +%Y%m%d-%H%M%S)
        terraform state pull > state-backup-${{ parameters.environment }}-$TIMESTAMP.json
        echo "State backup created: state-backup-${{ parameters.environment }}-$TIMESTAMP.json"

  - task: PublishPipelineArtifact@1
    displayName: 'Publish State Backup'
    inputs:
      targetPath: '${{ parameters.workingDirectory }}/state-backup-${{ parameters.environment }}-*.json'
      artifactName: 'terraform-state-backup-${{ parameters.environment }}'
      publishLocation: 'pipeline'

  - task: AzureCLI@2
    displayName: 'Terraform Apply'
    inputs:
      azureSubscription: '${{ parameters.azureServiceConnection }}'
      scriptType: 'bash'
      scriptLocation: 'inlineScript'
      workingDirectory: '${{ parameters.workingDirectory }}'
      inlineScript: |
        terraform apply -auto-approve tfplan-${{ parameters.environment }}.out

  - task: Bash@3
    displayName: 'Output Infrastructure Details'
    inputs:
      targetType: 'inline'
      workingDirectory: '${{ parameters.workingDirectory }}'
      script: |
        echo "# Infrastructure Outputs - ${{ parameters.environment }}" > outputs.md
        echo "" >> outputs.md
        terraform output -json | jq -r 'to_entries[] | "- **\(.key):** \(.value.value)"' >> outputs.md
        cat outputs.md

  - task: PublishPipelineArtifact@1
    displayName: 'Publish Infrastructure Outputs'
    inputs:
      targetPath: '${{ parameters.workingDirectory }}/outputs.md'
      artifactName: 'infrastructure-outputs-${{ parameters.environment }}'
      publishLocation: 'pipeline'

  - task: AzureCLI@2
    displayName: 'Tag Resources'
    inputs:
      azureSubscription: '${{ parameters.azureServiceConnection }}'
      scriptType: 'bash'
      scriptLocation: 'inlineScript'
      inlineScript: |
        RESOURCE_GROUP="applyforus-${{ parameters.environment }}-rg"

        echo "Tagging resources in $RESOURCE_GROUP..."

        az group update \
          --name $RESOURCE_GROUP \
          --tags \
            "LastDeployment=$(date +%Y-%m-%d)" \
            "DeployedBy=AzureDevOps" \
            "BuildId=$(Build.BuildId)" \
            "Environment=${{ parameters.environment }}" \
            "Platform=ApplyforUs"

  - task: Bash@3
    displayName: 'Verify Infrastructure Health'
    inputs:
      targetType: 'inline'
      script: |
        echo "Performing infrastructure health checks..."

        # Add custom health checks here
        echo "Health check completed successfully"
    continueOnError: true
