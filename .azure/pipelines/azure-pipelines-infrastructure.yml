# ============================================================================
# Infrastructure Pipeline - ApplyforUs Platform
# ============================================================================
# Terraform-based infrastructure deployment pipeline
#
# This pipeline:
# - Plans and applies Terraform configurations
# - Manages infrastructure across dev, test, and prod environments
# - Stores state in Azure Storage
# - Performs drift detection
# - Generates cost estimates
# - Includes manual approval for production changes
#
# Trigger: Manual or on infrastructure changes

trigger:
  branches:
    include:
      - main
      - develop
  paths:
    include:
      - infrastructure/terraform/**
      - .azure/pipelines/azure-pipelines-infrastructure.yml

pr:
  branches:
    include:
      - main
      - develop
  paths:
    include:
      - infrastructure/terraform/**

parameters:
  - name: action
    displayName: 'Terraform Action'
    type: string
    default: 'plan'
    values:
      - plan
      - apply
      - destroy

  - name: environment
    displayName: 'Target Environment'
    type: string
    default: 'dev'
    values:
      - dev
      - test
      - prod

variables:
  - group: applyforus-common
  - group: applyforus-terraform
  - group: applyforus-${{ parameters.environment }}

  # Terraform Configuration
  terraformVersion: 'latest'
  terraformWorkingDirectory: '$(System.DefaultWorkingDirectory)/infrastructure/terraform'

  # Azure Configuration
  azureServiceConnection: 'ApplyforUs-Azure-ServiceConnection'
  azureSubscription: '$(AZURE_SUBSCRIPTION_ID)'

  # Backend Configuration
  backendResourceGroup: 'applyforus-terraform-state-rg'
  backendStorageAccount: 'applyforustfstate'
  backendContainerName: 'tfstate'
  backendKey: 'applyforus-${{ parameters.environment }}.tfstate'

  # Environment-specific variables
  projectName: 'applyforus'
  location: 'eastus'

stages:
  # ============================================================================
  # Stage 1: Terraform Plan
  # ============================================================================
  - stage: TerraformPlan
    displayName: 'Terraform Plan - ${{ parameters.environment }}'
    jobs:
      - job: Plan
        displayName: 'Plan Infrastructure Changes'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: AzureCLI@2
            displayName: 'Setup Terraform Backend Storage'
            inputs:
              azureSubscription: '$(azureServiceConnection)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Setting up Terraform backend storage..."

                # Create resource group if it doesn't exist
                az group create \
                  --name $(backendResourceGroup) \
                  --location $(location) \
                  --tags "Purpose=TerraformState" "Platform=ApplyforUs"

                # Create storage account if it doesn't exist
                az storage account create \
                  --name $(backendStorageAccount) \
                  --resource-group $(backendResourceGroup) \
                  --location $(location) \
                  --sku Standard_LRS \
                  --encryption-services blob \
                  --min-tls-version TLS1_2 \
                  --allow-blob-public-access false

                # Get storage account key
                ACCOUNT_KEY=$(az storage account keys list \
                  --resource-group $(backendResourceGroup) \
                  --account-name $(backendStorageAccount) \
                  --query '[0].value' -o tsv)

                # Create container if it doesn't exist
                az storage container create \
                  --name $(backendContainerName) \
                  --account-name $(backendStorageAccount) \
                  --account-key "$ACCOUNT_KEY"

                echo "Terraform backend storage is ready"

          - template: templates/terraform-plan.yml
            parameters:
              environment: '${{ parameters.environment }}'
              terraformVersion: '$(terraformVersion)'
              workingDirectory: '$(terraformWorkingDirectory)'
              azureServiceConnection: '$(azureServiceConnection)'
              backendResourceGroup: '$(backendResourceGroup)'
              backendStorageAccount: '$(backendStorageAccount)'
              backendContainerName: '$(backendContainerName)'

      - job: DriftDetection
        displayName: 'Drift Detection'
        dependsOn: Plan
        condition: eq('${{ parameters.action }}', 'plan')
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: TerraformInstaller@0
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: '$(terraformVersion)'

          - task: TerraformTaskV4@4
            displayName: 'Terraform Init'
            inputs:
              provider: 'azurerm'
              command: 'init'
              workingDirectory: '$(terraformWorkingDirectory)'
              backendServiceArm: '$(azureServiceConnection)'
              backendAzureRmResourceGroupName: '$(backendResourceGroup)'
              backendAzureRmStorageAccountName: '$(backendStorageAccount)'
              backendAzureRmContainerName: '$(backendContainerName)'
              backendAzureRmKey: '$(backendKey)'

          - task: TerraformTaskV4@4
            displayName: 'Terraform Refresh'
            inputs:
              provider: 'azurerm'
              command: 'refresh'
              workingDirectory: '$(terraformWorkingDirectory)'
              environmentServiceNameAzureRM: '$(azureServiceConnection)'
              commandOptions: '-var="environment=${{ parameters.environment }}" -var="project_name=$(projectName)"'

          - task: Bash@3
            displayName: 'Check for Drift'
            inputs:
              targetType: 'inline'
              workingDirectory: '$(terraformWorkingDirectory)'
              script: |
                echo "Checking for infrastructure drift..."

                terraform plan \
                  -var="environment=${{ parameters.environment }}" \
                  -var="project_name=$(projectName)" \
                  -detailed-exitcode \
                  -out=drift-check.tfplan || EXIT_CODE=$?

                if [ $EXIT_CODE -eq 2 ]; then
                  echo "##vso[task.logissue type=warning]DRIFT DETECTED: Infrastructure has drifted from Terraform state"

                  # Generate drift report
                  terraform show drift-check.tfplan > drift-report.txt

                  echo "Drift Report:"
                  cat drift-report.txt
                elif [ $EXIT_CODE -eq 0 ]; then
                  echo "No drift detected. Infrastructure matches Terraform state."
                else
                  echo "##vso[task.logissue type=error]Drift detection failed with exit code $EXIT_CODE"
                  exit 1
                fi

          - task: PublishPipelineArtifact@1
            displayName: 'Publish Drift Report'
            inputs:
              targetPath: '$(terraformWorkingDirectory)/drift-report.txt'
              artifactName: 'drift-report-${{ parameters.environment }}'
              publishLocation: 'pipeline'
            condition: succeededOrFailed()

  # ============================================================================
  # Stage 2: Terraform Apply (Dev/Test - Auto)
  # ============================================================================
  - ${{ if and(eq(parameters.action, 'apply'), ne(parameters.environment, 'prod')) }}:
    - stage: TerraformApply
      displayName: 'Apply Infrastructure - ${{ parameters.environment }}'
      dependsOn: TerraformPlan
      condition: succeeded()
      jobs:
        - job: ApplyInfrastructure
          displayName: 'Apply Terraform Changes'
          pool:
            vmImage: 'ubuntu-latest'
          steps:
            - checkout: self

            - template: templates/terraform-apply.yml
              parameters:
                environment: '${{ parameters.environment }}'
                terraformVersion: '$(terraformVersion)'
                workingDirectory: '$(terraformWorkingDirectory)'
                azureServiceConnection: '$(azureServiceConnection)'
                backendResourceGroup: '$(backendResourceGroup)'
                backendStorageAccount: '$(backendStorageAccount)'
                backendContainerName: '$(backendContainerName)'
                autoApprove: false

        - job: PostApplyValidation
          displayName: 'Post-Apply Validation'
          dependsOn: ApplyInfrastructure
          pool:
            vmImage: 'ubuntu-latest'
          steps:
            - task: AzureCLI@2
              displayName: 'Validate Deployed Resources'
              inputs:
                azureSubscription: '$(azureServiceConnection)'
                scriptType: 'bash'
                scriptLocation: 'inlineScript'
                inlineScript: |
                  echo "Validating deployed resources..."

                  RESOURCE_GROUP="applyforus-${{ parameters.environment }}-rg"

                  # Check if resource group exists
                  az group show --name $RESOURCE_GROUP

                  # List all resources
                  echo "Resources in $RESOURCE_GROUP:"
                  az resource list --resource-group $RESOURCE_GROUP --output table

                  # Check AKS cluster
                  AKS_NAME="applyforus-${{ parameters.environment }}-aks"
                  if az aks show --name $AKS_NAME --resource-group $RESOURCE_GROUP &>/dev/null; then
                    echo "AKS cluster $AKS_NAME is running"
                    az aks show --name $AKS_NAME --resource-group $RESOURCE_GROUP --query "powerState.code" -o tsv
                  fi

                  # Check ACR
                  ACR_NAME="applyforusacr${{ parameters.environment }}"
                  if az acr show --name $ACR_NAME --resource-group $RESOURCE_GROUP &>/dev/null; then
                    echo "Container Registry $ACR_NAME is available"
                  fi

                  echo "Infrastructure validation completed"

  # ============================================================================
  # Stage 3: Terraform Apply (Production - Manual Approval)
  # ============================================================================
  - ${{ if and(eq(parameters.action, 'apply'), eq(parameters.environment, 'prod')) }}:
    - stage: ProductionApproval
      displayName: 'Production Approval'
      dependsOn: TerraformPlan
      jobs:
        - job: WaitForApproval
          displayName: 'Wait for Manual Approval'
          pool: server
          steps:
            - task: ManualValidation@0
              displayName: 'Approve Production Infrastructure Changes'
              inputs:
                notifyUsers: ''
                instructions: |
                  PRODUCTION INFRASTRUCTURE CHANGE REQUEST

                  Environment: Production
                  Action: Apply Terraform Changes

                  Please review the Terraform plan artifact before approving.

                  IMPORTANT: This will modify production infrastructure.

                  Approval Required By:
                  - Infrastructure Lead
                  - Security Team
                  - Platform Owner
                onTimeout: 'reject'

    - stage: TerraformApplyProd
      displayName: 'Apply Infrastructure - Production'
      dependsOn: ProductionApproval
      condition: succeeded()
      jobs:
        - job: ApplyProdInfrastructure
          displayName: 'Apply Production Changes'
          pool:
            vmImage: 'ubuntu-latest'
          steps:
            - checkout: self

            - template: templates/terraform-apply.yml
              parameters:
                environment: 'prod'
                terraformVersion: '$(terraformVersion)'
                workingDirectory: '$(terraformWorkingDirectory)'
                azureServiceConnection: '$(azureServiceConnection)'
                backendResourceGroup: '$(backendResourceGroup)'
                backendStorageAccount: '$(backendStorageAccount)'
                backendContainerName: '$(backendContainerName)'
                autoApprove: false

            - task: Bash@3
              displayName: 'Notify Stakeholders'
              inputs:
                targetType: 'inline'
                script: |
                  echo "Production infrastructure has been updated"
                  echo "Build ID: $(Build.BuildId)"
                  echo "Environment: Production"
                  echo "Applied By: $(Build.RequestedFor)"

  # ============================================================================
  # Stage 4: Terraform Destroy (Requires Manual Approval)
  # ============================================================================
  - ${{ if eq(parameters.action, 'destroy') }}:
    - stage: DestroyApproval
      displayName: 'Destroy Approval'
      dependsOn: TerraformPlan
      jobs:
        - job: WaitForDestroyApproval
          displayName: 'Wait for Destroy Approval'
          pool: server
          steps:
            - task: ManualValidation@0
              displayName: 'Approve Infrastructure Destroy'
              inputs:
                notifyUsers: ''
                instructions: |
                  INFRASTRUCTURE DESTROY REQUEST

                  Environment: ${{ parameters.environment }}
                  Action: DESTROY ALL RESOURCES

                  WARNING: This action is IRREVERSIBLE and will:
                  - Delete all infrastructure resources
                  - Remove all data (unless backups exist)
                  - Cause service downtime

                  This action requires approval from:
                  - Platform Owner
                  - Security Team
                  - Technical Lead

                  Type the environment name to confirm: ${{ parameters.environment }}
                onTimeout: 'reject'

    - stage: TerraformDestroy
      displayName: 'Destroy Infrastructure'
      dependsOn: DestroyApproval
      jobs:
        - job: DestroyInfrastructure
          displayName: 'Destroy Resources'
          pool:
            vmImage: 'ubuntu-latest'
          steps:
            - checkout: self

            - task: TerraformInstaller@0
              displayName: 'Install Terraform'
              inputs:
                terraformVersion: '$(terraformVersion)'

            - task: TerraformTaskV4@4
              displayName: 'Terraform Init'
              inputs:
                provider: 'azurerm'
                command: 'init'
                workingDirectory: '$(terraformWorkingDirectory)'
                backendServiceArm: '$(azureServiceConnection)'
                backendAzureRmResourceGroupName: '$(backendResourceGroup)'
                backendAzureRmStorageAccountName: '$(backendStorageAccount)'
                backendAzureRmContainerName: '$(backendContainerName)'
                backendAzureRmKey: '$(backendKey)'

            - task: Bash@3
              displayName: 'Backup State Before Destroy'
              inputs:
                targetType: 'inline'
                workingDirectory: '$(terraformWorkingDirectory)'
                script: |
                  TIMESTAMP=$(date +%Y%m%d-%H%M%S)
                  terraform state pull > state-backup-before-destroy-$TIMESTAMP.json
                  echo "State backed up to: state-backup-before-destroy-$TIMESTAMP.json"

            - task: PublishPipelineArtifact@1
              displayName: 'Publish State Backup'
              inputs:
                targetPath: '$(terraformWorkingDirectory)/state-backup-before-destroy-*.json'
                artifactName: 'state-backup-destroy-${{ parameters.environment }}'

            - task: TerraformTaskV4@4
              displayName: 'Terraform Destroy'
              inputs:
                provider: 'azurerm'
                command: 'destroy'
                workingDirectory: '$(terraformWorkingDirectory)'
                environmentServiceNameAzureRM: '$(azureServiceConnection)'
                commandOptions: '-var="environment=${{ parameters.environment }}" -var="project_name=$(projectName)" -auto-approve'

            - task: Bash@3
              displayName: 'Verify Destruction'
              inputs:
                targetType: 'inline'
                script: |
                  echo "Infrastructure destruction completed for ${{ parameters.environment }}"
                  echo "All resources have been removed"

  # ============================================================================
  # Stage 5: Documentation and Reporting
  # ============================================================================
  - stage: Documentation
    displayName: 'Generate Documentation'
    condition: succeededOrFailed()
    jobs:
      - job: GenerateDocs
        displayName: 'Generate Infrastructure Documentation'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: Bash@3
            displayName: 'Generate Infrastructure Documentation'
            inputs:
              targetType: 'inline'
              workingDirectory: '$(terraformWorkingDirectory)'
              script: |
                cat > $(Build.ArtifactStagingDirectory)/infrastructure-summary.md << EOF
                # ApplyforUs Infrastructure Summary

                **Environment:** ${{ parameters.environment }}
                **Action:** ${{ parameters.action }}
                **Date:** $(date)
                **Executed By:** $(Build.RequestedFor)
                **Build ID:** $(Build.BuildId)

                ## Infrastructure Components

                The ApplyforUs platform infrastructure includes:

                ### Core Services
                - **Resource Group:** applyforus-${{ parameters.environment }}-rg
                - **AKS Cluster:** applyforus-${{ parameters.environment }}-aks
                - **Container Registry:** applyforusacr${{ parameters.environment }}
                - **Key Vault:** applyforus-${{ parameters.environment }}-kv
                - **Virtual Network:** applyforus-${{ parameters.environment }}-vnet

                ### Data Layer
                - **SQL Database:** applyforus-${{ parameters.environment }}-sqldb
                - **Redis Cache:** applyforus-${{ parameters.environment }}-redis
                - **Service Bus:** applyforus-${{ parameters.environment }}-sb

                ### Monitoring
                - **Application Insights:** applyforus-${{ parameters.environment }}-ai
                - **Log Analytics:** applyforus-${{ parameters.environment }}-law

                ## State Management

                Terraform state is stored in:
                - **Storage Account:** $(backendStorageAccount)
                - **Container:** $(backendContainerName)
                - **State File:** $(backendKey)

                ## Next Steps

                1. Review the Terraform plan/apply outputs
                2. Validate deployed resources in Azure Portal
                3. Update DNS records if needed
                4. Configure monitoring alerts
                5. Run deployment pipeline to deploy applications

                EOF

                cat $(Build.ArtifactStagingDirectory)/infrastructure-summary.md

          - task: PublishPipelineArtifact@1
            displayName: 'Publish Infrastructure Documentation'
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)/infrastructure-summary.md'
              artifactName: 'infrastructure-docs-${{ parameters.environment }}'
              publishLocation: 'pipeline'
