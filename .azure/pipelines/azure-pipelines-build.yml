# ============================================================================
# Build Pipeline - ApplyforUs Platform
# ============================================================================
# Multi-stage CI pipeline for building, testing, and publishing Docker images
#
# This pipeline:
# - Builds all microservices and web applications
# - Runs unit tests with coverage reporting
# - Performs linting and type checking
# - Runs security scans
# - Builds and tags Docker images
# - Pushes images to Azure Container Registry
# - Publishes build artifacts
#
# Trigger: Runs on pull requests and commits to develop/main branches

trigger:
  branches:
    include:
      - main
      - develop
      - feature/*
      - hotfix/*
  paths:
    exclude:
      - docs/**
      - '**.md'
      - .github/**

pr:
  branches:
    include:
      - main
      - develop
  paths:
    exclude:
      - docs/**
      - '**.md'

variables:
  # Build Configuration
  buildConfiguration: 'Release'
  nodeVersion: '20.x'
  pythonVersion: '3.11'

  # Container Registry
  containerRegistry: 'ApplyforUs-ACR'
  containerRegistryName: 'applyforusacr'
  containerRegistryUrl: '$(containerRegistryName).azurecr.io'

  # Semantic Versioning
  majorVersion: '1'
  minorVersion: '0'
  patchVersion: $[counter(format('{0}.{1}', variables['majorVersion'], variables['minorVersion']), 0)]
  semanticVersion: '$(majorVersion).$(minorVersion).$(patchVersion)'

  # Image Tag
  imageTag: '$(semanticVersion)-$(Build.BuildId)'

  # Paths
  rootPath: '$(System.DefaultWorkingDirectory)'

  # Services to Build
  services: >
    web,
    auth-service,
    job-service,
    resume-service,
    user-service,
    ai-service,
    notification-service,
    auto-apply-service,
    analytics-service,
    orchestrator-service

stages:
  # ============================================================================
  # Stage 1: Code Quality and Testing
  # ============================================================================
  - stage: CodeQuality
    displayName: 'Code Quality & Testing'
    jobs:
      - job: Lint
        displayName: 'Lint & Type Check'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 1

          - task: NodeTool@0
            displayName: 'Install Node.js'
            inputs:
              versionSpec: '$(nodeVersion)'

          - task: Cache@2
            displayName: 'Cache npm packages'
            inputs:
              key: 'npm | "$(Agent.OS)" | package-lock.json'
              path: '$(System.DefaultWorkingDirectory)/node_modules'
              restoreKeys: |
                npm | "$(Agent.OS)"

          - script: |
              npm ci --legacy-peer-deps
            displayName: 'Install Dependencies'

          - script: |
              npm run format:check
            displayName: 'Check Code Formatting'
            continueOnError: true

          - script: |
              npm run lint
            displayName: 'Run ESLint'

          - script: |
              npm run type-check
            displayName: 'TypeScript Type Check'

          - task: PublishPipelineArtifact@1
            displayName: 'Publish Lint Results'
            inputs:
              targetPath: '$(System.DefaultWorkingDirectory)'
              artifactName: 'lint-results'
            condition: succeededOrFailed()

      - job: UnitTests
        displayName: 'Unit Tests'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 1

          - task: NodeTool@0
            displayName: 'Install Node.js'
            inputs:
              versionSpec: '$(nodeVersion)'

          - task: Cache@2
            displayName: 'Cache npm packages'
            inputs:
              key: 'npm | "$(Agent.OS)" | package-lock.json'
              path: '$(System.DefaultWorkingDirectory)/node_modules'

          - script: |
              npm ci --legacy-peer-deps
            displayName: 'Install Dependencies'

          - script: |
              npm run test:unit -- --coverage --ci --reporters=default --reporters=jest-junit
            displayName: 'Run Unit Tests'
            env:
              JEST_JUNIT_OUTPUT_DIR: '$(System.DefaultWorkingDirectory)/test-results'
              JEST_JUNIT_OUTPUT_NAME: 'junit.xml'

          - task: PublishTestResults@2
            displayName: 'Publish Test Results'
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: '**/junit.xml'
              searchFolder: '$(System.DefaultWorkingDirectory)/test-results'
              mergeTestResults: true
              failTaskOnFailedTests: true
              testRunTitle: 'Unit Tests'
            condition: succeededOrFailed()

          - task: PublishCodeCoverageResults@1
            displayName: 'Publish Code Coverage'
            inputs:
              codeCoverageTool: 'Cobertura'
              summaryFileLocation: '$(System.DefaultWorkingDirectory)/coverage/cobertura-coverage.xml'
              reportDirectory: '$(System.DefaultWorkingDirectory)/coverage'
              failIfCoverageEmpty: false
            condition: succeededOrFailed()

      - job: SecurityScan
        displayName: 'Security Scanning'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 0

          - template: templates/security-scan.yml
            parameters:
              scanType: 'all'
              workingDirectory: '$(System.DefaultWorkingDirectory)'
              failOnHighSeverity: false
              failOnCriticalSeverity: true

  # ============================================================================
  # Stage 2: Build Docker Images
  # ============================================================================
  - stage: BuildImages
    displayName: 'Build Docker Images'
    dependsOn: CodeQuality
    condition: succeeded()
    jobs:
      # Web Application
      - job: BuildWeb
        displayName: 'Build Web App'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: Docker@2
            displayName: 'Login to ACR'
            inputs:
              command: 'login'
              containerRegistry: '$(containerRegistry)'

          - template: templates/docker-build.yml
            parameters:
              serviceName: 'web'
              dockerfilePath: 'apps/web/Dockerfile'
              buildContext: '.'
              imageTag: '$(imageTag)'
              additionalBuildArgs: '--build-arg NODE_VERSION=$(nodeVersion) --build-arg BUILD_DATE=$(Build.Date)'
              enableBuildCache: true

      # Auth Service
      - job: BuildAuthService
        displayName: 'Build Auth Service'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: Docker@2
            displayName: 'Login to ACR'
            inputs:
              command: 'login'
              containerRegistry: '$(containerRegistry)'

          - template: templates/docker-build.yml
            parameters:
              serviceName: 'auth-service'
              dockerfilePath: 'services/auth-service/Dockerfile'
              buildContext: '.'
              imageTag: '$(imageTag)'
              enableBuildCache: true

      # Job Service
      - job: BuildJobService
        displayName: 'Build Job Service'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: Docker@2
            displayName: 'Login to ACR'
            inputs:
              command: 'login'
              containerRegistry: '$(containerRegistry)'

          - template: templates/docker-build.yml
            parameters:
              serviceName: 'job-service'
              dockerfilePath: 'services/job-service/Dockerfile'
              buildContext: '.'
              imageTag: '$(imageTag)'
              enableBuildCache: true

      # Resume Service
      - job: BuildResumeService
        displayName: 'Build Resume Service'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: Docker@2
            displayName: 'Login to ACR'
            inputs:
              command: 'login'
              containerRegistry: '$(containerRegistry)'

          - template: templates/docker-build.yml
            parameters:
              serviceName: 'resume-service'
              dockerfilePath: 'services/resume-service/Dockerfile'
              buildContext: '.'
              imageTag: '$(imageTag)'
              enableBuildCache: true

      # User Service
      - job: BuildUserService
        displayName: 'Build User Service'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: Docker@2
            displayName: 'Login to ACR'
            inputs:
              command: 'login'
              containerRegistry: '$(containerRegistry)'

          - template: templates/docker-build.yml
            parameters:
              serviceName: 'user-service'
              dockerfilePath: 'services/user-service/Dockerfile'
              buildContext: '.'
              imageTag: '$(imageTag)'
              enableBuildCache: true

      # AI Service
      - job: BuildAIService
        displayName: 'Build AI Service'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: Docker@2
            displayName: 'Login to ACR'
            inputs:
              command: 'login'
              containerRegistry: '$(containerRegistry)'

          - template: templates/docker-build.yml
            parameters:
              serviceName: 'ai-service'
              dockerfilePath: 'services/ai-service/Dockerfile'
              buildContext: '.'
              imageTag: '$(imageTag)'
              additionalBuildArgs: '--build-arg PYTHON_VERSION=$(pythonVersion)'
              enableBuildCache: true

      # Notification Service
      - job: BuildNotificationService
        displayName: 'Build Notification Service'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: Docker@2
            displayName: 'Login to ACR'
            inputs:
              command: 'login'
              containerRegistry: '$(containerRegistry)'

          - template: templates/docker-build.yml
            parameters:
              serviceName: 'notification-service'
              dockerfilePath: 'services/notification-service/Dockerfile'
              buildContext: '.'
              imageTag: '$(imageTag)'
              enableBuildCache: true

      # Auto-Apply Service
      - job: BuildAutoApplyService
        displayName: 'Build Auto-Apply Service'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: Docker@2
            displayName: 'Login to ACR'
            inputs:
              command: 'login'
              containerRegistry: '$(containerRegistry)'

          - template: templates/docker-build.yml
            parameters:
              serviceName: 'auto-apply-service'
              dockerfilePath: 'services/auto-apply-service/Dockerfile'
              buildContext: '.'
              imageTag: '$(imageTag)'
              enableBuildCache: true

      # Analytics Service
      - job: BuildAnalyticsService
        displayName: 'Build Analytics Service'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: Docker@2
            displayName: 'Login to ACR'
            inputs:
              command: 'login'
              containerRegistry: '$(containerRegistry)'

          - template: templates/docker-build.yml
            parameters:
              serviceName: 'analytics-service'
              dockerfilePath: 'services/analytics-service/Dockerfile'
              buildContext: '.'
              imageTag: '$(imageTag)'
              enableBuildCache: true

      # Orchestrator Service
      - job: BuildOrchestratorService
        displayName: 'Build Orchestrator Service'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: Docker@2
            displayName: 'Login to ACR'
            inputs:
              command: 'login'
              containerRegistry: '$(containerRegistry)'

          - template: templates/docker-build.yml
            parameters:
              serviceName: 'orchestrator-service'
              dockerfilePath: 'services/orchestrator-service/Dockerfile'
              buildContext: '.'
              imageTag: '$(imageTag)'
              enableBuildCache: true

  # ============================================================================
  # Stage 3: Push to Container Registry
  # ============================================================================
  - stage: PushImages
    displayName: 'Push to ACR'
    dependsOn: BuildImages
    condition: and(succeeded(), in(variables['Build.SourceBranch'], 'refs/heads/main', 'refs/heads/develop'))
    jobs:
      - job: PushAllImages
        displayName: 'Push All Images to ACR'
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          matrix:
            web:
              serviceName: 'web'
            authService:
              serviceName: 'auth-service'
            jobService:
              serviceName: 'job-service'
            resumeService:
              serviceName: 'resume-service'
            userService:
              serviceName: 'user-service'
            aiService:
              serviceName: 'ai-service'
            notificationService:
              serviceName: 'notification-service'
            autoApplyService:
              serviceName: 'auto-apply-service'
            analyticsService:
              serviceName: 'analytics-service'
            orchestratorService:
              serviceName: 'orchestrator-service'
        steps:
          - download: current
            artifact: 'docker-image-$(serviceName)'

          - task: Docker@2
            displayName: 'Load Docker Image'
            inputs:
              command: 'load'
              arguments: '-i $(Pipeline.Workspace)/docker-image-$(serviceName)/$(serviceName)-$(imageTag).tar'

          - template: templates/docker-push.yml
            parameters:
              serviceName: '$(serviceName)'
              imageTag: '$(imageTag)'
              containerRegistry: '$(containerRegistry)'
              additionalTags:
                - '$(semanticVersion)'
                - '$(Build.SourceBranchName)'
              enableVulnerabilityScan: true

  # ============================================================================
  # Stage 4: Create Release Artifact
  # ============================================================================
  - stage: CreateRelease
    displayName: 'Create Release Artifact'
    dependsOn: PushImages
    condition: succeeded()
    jobs:
      - job: PackageRelease
        displayName: 'Package Release Information'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: Bash@3
            displayName: 'Generate Release Notes'
            inputs:
              targetType: 'inline'
              script: |
                mkdir -p $(Build.ArtifactStagingDirectory)/release

                cat > $(Build.ArtifactStagingDirectory)/release/release-notes.md << EOF
                # ApplyforUs Platform Release

                **Version:** $(semanticVersion)
                **Build ID:** $(Build.BuildId)
                **Build Number:** $(Build.BuildNumber)
                **Date:** $(Build.Date)
                **Branch:** $(Build.SourceBranchName)
                **Commit:** $(Build.SourceVersion)

                ## Services Built

                All services have been built and pushed to ACR with the following tags:
                - \`$(imageTag)\`
                - \`$(semanticVersion)\`
                - \`$(Build.SourceBranchName)\`
                - \`latest\`

                ## Docker Images

                - applyforus-web:$(imageTag)
                - applyforus-auth-service:$(imageTag)
                - applyforus-job-service:$(imageTag)
                - applyforus-resume-service:$(imageTag)
                - applyforus-user-service:$(imageTag)
                - applyforus-ai-service:$(imageTag)
                - applyforus-notification-service:$(imageTag)
                - applyforus-auto-apply-service:$(imageTag)
                - applyforus-analytics-service:$(imageTag)
                - applyforus-orchestrator-service:$(imageTag)

                ## Container Registry

                Registry: $(containerRegistryUrl)

                ## Deployment

                Use the deployment pipeline to deploy this version to your target environment.

                \`\`\`bash
                # Pull images
                docker pull $(containerRegistryUrl)/applyforus-web:$(imageTag)
                # ... repeat for all services
                \`\`\`
                EOF

                cat $(Build.ArtifactStagingDirectory)/release/release-notes.md

          - task: Bash@3
            displayName: 'Generate Version File'
            inputs:
              targetType: 'inline'
              script: |
                cat > $(Build.ArtifactStagingDirectory)/release/version.json << EOF
                {
                  "version": "$(semanticVersion)",
                  "buildId": "$(Build.BuildId)",
                  "buildNumber": "$(Build.BuildNumber)",
                  "imageTag": "$(imageTag)",
                  "branch": "$(Build.SourceBranchName)",
                  "commit": "$(Build.SourceVersion)",
                  "date": "$(Build.Date)",
                  "services": [
                    "web",
                    "auth-service",
                    "job-service",
                    "resume-service",
                    "user-service",
                    "ai-service",
                    "notification-service",
                    "auto-apply-service",
                    "analytics-service",
                    "orchestrator-service"
                  ]
                }
                EOF

          - task: PublishBuildArtifacts@1
            displayName: 'Publish Release Artifact'
            inputs:
              pathToPublish: '$(Build.ArtifactStagingDirectory)/release'
              artifactName: 'release-$(semanticVersion)'
              publishLocation: 'Container'
