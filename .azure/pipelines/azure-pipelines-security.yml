# ============================================================================
# Security Pipeline - ApplyforUs Platform
# ============================================================================
# Comprehensive security scanning pipeline
#
# This pipeline:
# - Performs SAST (Static Application Security Testing)
# - Scans dependencies for vulnerabilities
# - Detects secrets in code
# - Scans container images
# - Performs compliance checks
# - Generates security reports
#
# Trigger: Scheduled nightly and on security-related changes

trigger:
  branches:
    include:
      - main
      - develop
  paths:
    exclude:
      - docs/**
      - '**.md'

schedules:
  - cron: '0 2 * * *'
    displayName: 'Nightly Security Scan'
    branches:
      include:
        - main
        - develop
    always: true

pr:
  branches:
    include:
      - main
      - develop

variables:
  - group: applyforus-common
  - group: applyforus-security

  # Scan Configuration
  scanWorkingDirectory: '$(System.DefaultWorkingDirectory)'
  failOnHighSeverity: false
  failOnCriticalSeverity: true

  # Container Registry
  containerRegistry: 'ApplyforUs-ACR'
  containerRegistryUrl: 'applyforusacr.azurecr.io'

stages:
  # ============================================================================
  # Stage 1: Code Security Scanning
  # ============================================================================
  - stage: CodeSecurityScan
    displayName: 'Code Security Scanning'
    jobs:
      - job: SecretDetection
        displayName: 'Secret Detection'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 0

          - task: UsePythonVersion@0
            displayName: 'Use Python 3.11'
            inputs:
              versionSpec: '3.11'

          - task: Bash@3
            displayName: 'Install Secret Scanning Tools'
            inputs:
              targetType: 'inline'
              script: |
                pip install truffleHog detect-secrets

          - task: Bash@3
            displayName: 'Scan for Secrets with TruffleHog'
            inputs:
              targetType: 'inline'
              workingDirectory: '$(scanWorkingDirectory)'
              script: |
                echo "Scanning for secrets with TruffleHog..."

                trufflehog filesystem . \
                  --json \
                  --no-update \
                  > $(Build.ArtifactStagingDirectory)/trufflehog-results.json || true

                # Check if secrets were found
                if [ -s $(Build.ArtifactStagingDirectory)/trufflehog-results.json ]; then
                  echo "##vso[task.logissue type=error]SECRETS DETECTED! Review the scan results immediately."
                  cat $(Build.ArtifactStagingDirectory)/trufflehog-results.json

                  if [ "$(failOnCriticalSeverity)" = "true" ]; then
                    exit 1
                  fi
                else
                  echo "No secrets detected by TruffleHog"
                fi

          - task: Bash@3
            displayName: 'Scan with detect-secrets'
            inputs:
              targetType: 'inline'
              workingDirectory: '$(scanWorkingDirectory)'
              script: |
                echo "Scanning with detect-secrets..."

                detect-secrets scan --all-files \
                  > $(Build.ArtifactStagingDirectory)/detect-secrets-baseline.json || true

                # Audit the baseline
                detect-secrets audit $(Build.ArtifactStagingDirectory)/detect-secrets-baseline.json || true

                echo "detect-secrets scan completed"

          - task: PublishPipelineArtifact@1
            displayName: 'Publish Secret Scan Results'
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)'
              artifactName: 'secret-scan-results'
              publishLocation: 'pipeline'

      - job: SASTScan
        displayName: 'SAST - Static Code Analysis'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 0

          - task: UsePythonVersion@0
            displayName: 'Use Python 3.11'
            inputs:
              versionSpec: '3.11'

          - task: Bash@3
            displayName: 'Install Semgrep'
            inputs:
              targetType: 'inline'
              script: |
                pip install semgrep

          - task: Bash@3
            displayName: 'Run Semgrep SAST Scan'
            inputs:
              targetType: 'inline'
              workingDirectory: '$(scanWorkingDirectory)'
              script: |
                echo "Running Semgrep SAST scan..."

                # Run with multiple rulesets
                semgrep scan \
                  --config=auto \
                  --config=p/owasp-top-ten \
                  --config=p/security-audit \
                  --json \
                  --output=$(Build.ArtifactStagingDirectory)/semgrep-results.json \
                  . || true

                # Generate SARIF format for Azure DevOps
                semgrep scan \
                  --config=auto \
                  --sarif \
                  --output=$(Build.ArtifactStagingDirectory)/semgrep-results.sarif \
                  . || true

                # Generate human-readable report
                semgrep scan \
                  --config=auto \
                  . > $(Build.ArtifactStagingDirectory)/semgrep-report.txt || true

                echo "Semgrep scan completed"

                # Check for critical issues
                CRITICAL_COUNT=$(jq '[.results[] | select(.extra.severity == "ERROR")] | length' $(Build.ArtifactStagingDirectory)/semgrep-results.json)

                echo "Critical issues found: $CRITICAL_COUNT"

                if [ "$CRITICAL_COUNT" -gt "0" ] && [ "$(failOnCriticalSeverity)" = "true" ]; then
                  echo "##vso[task.logissue type=error]Critical security issues found!"
                  exit 1
                fi

          - task: PublishPipelineArtifact@1
            displayName: 'Publish SAST Results'
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)'
              artifactName: 'sast-scan-results'
              publishLocation: 'pipeline'

      - job: LicenseCompliance
        displayName: 'License Compliance Check'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: NodeTool@0
            displayName: 'Install Node.js'
            inputs:
              versionSpec: '20.x'

          - task: Bash@3
            displayName: 'Install License Checker'
            inputs:
              targetType: 'inline'
              script: |
                npm install -g license-checker license-report

          - task: Bash@3
            displayName: 'Check NPM Licenses'
            inputs:
              targetType: 'inline'
              workingDirectory: '$(scanWorkingDirectory)'
              script: |
                echo "Checking NPM package licenses..."

                npm ci --legacy-peer-deps || echo "Dependencies install completed"

                # Generate license report
                license-checker --json > $(Build.ArtifactStagingDirectory)/npm-licenses.json || true
                license-checker --csv > $(Build.ArtifactStagingDirectory)/npm-licenses.csv || true

                # Check for problematic licenses
                license-checker --onlyAllow 'MIT;Apache-2.0;BSD-2-Clause;BSD-3-Clause;ISC;CC0-1.0' \
                  --summary || echo "Some packages have licenses requiring review"

                echo "License compliance check completed"

          - task: PublishPipelineArtifact@1
            displayName: 'Publish License Report'
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)'
              artifactName: 'license-compliance-report'
              publishLocation: 'pipeline'

  # ============================================================================
  # Stage 2: Dependency Scanning
  # ============================================================================
  - stage: DependencyScan
    displayName: 'Dependency Vulnerability Scanning'
    jobs:
      - job: NPMDependencies
        displayName: 'NPM Dependency Scan'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: NodeTool@0
            displayName: 'Install Node.js'
            inputs:
              versionSpec: '20.x'

          - task: Bash@3
            displayName: 'Install Dependencies'
            inputs:
              targetType: 'inline'
              script: |
                npm ci --legacy-peer-deps

          - task: Bash@3
            displayName: 'Run npm audit'
            inputs:
              targetType: 'inline'
              script: |
                echo "Running npm audit..."

                # Run npm audit and save results
                npm audit --json > $(Build.ArtifactStagingDirectory)/npm-audit.json || true
                npm audit > $(Build.ArtifactStagingDirectory)/npm-audit.txt || true

                # Install npm-audit-html for better reporting
                npm install -g npm-audit-html

                # Generate HTML report
                npm-audit-html \
                  --input $(Build.ArtifactStagingDirectory)/npm-audit.json \
                  --output $(Build.ArtifactStagingDirectory)/npm-audit.html

                # Check severity levels
                if [ -f "$(Build.ArtifactStagingDirectory)/npm-audit.json" ]; then
                  HIGH_VULNS=$(jq '.metadata.vulnerabilities.high // 0' $(Build.ArtifactStagingDirectory)/npm-audit.json)
                  CRITICAL_VULNS=$(jq '.metadata.vulnerabilities.critical // 0' $(Build.ArtifactStagingDirectory)/npm-audit.json)

                  echo "High severity vulnerabilities: $HIGH_VULNS"
                  echo "Critical severity vulnerabilities: $CRITICAL_VULNS"

                  if [ "$CRITICAL_VULNS" -gt "0" ]; then
                    echo "##vso[task.logissue type=error]Critical vulnerabilities found in NPM dependencies!"
                    if [ "$(failOnCriticalSeverity)" = "true" ]; then
                      exit 1
                    fi
                  fi
                fi

          - task: PublishPipelineArtifact@1
            displayName: 'Publish NPM Audit Results'
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)'
              artifactName: 'npm-dependency-scan'
              publishLocation: 'pipeline'

      - job: PythonDependencies
        displayName: 'Python Dependency Scan'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: UsePythonVersion@0
            displayName: 'Use Python 3.11'
            inputs:
              versionSpec: '3.11'

          - task: Bash@3
            displayName: 'Install Safety'
            inputs:
              targetType: 'inline'
              script: |
                pip install safety

          - task: Bash@3
            displayName: 'Scan Python Dependencies'
            inputs:
              targetType: 'inline'
              workingDirectory: '$(scanWorkingDirectory)'
              script: |
                echo "Scanning Python dependencies..."

                # Find all requirements files
                find . -name "requirements*.txt" -type f | while read req_file; do
                  echo "Scanning $req_file"

                  BASENAME=$(basename "$req_file" .txt | sed 's/[^a-zA-Z0-9]/-/g')

                  # Run safety check
                  safety check \
                    --file "$req_file" \
                    --json \
                    --output $(Build.ArtifactStagingDirectory)/safety-${BASENAME}.json || true

                  safety check \
                    --file "$req_file" \
                    --output text \
                    > $(Build.ArtifactStagingDirectory)/safety-${BASENAME}.txt || true
                done

                echo "Python dependency scan completed"

          - task: PublishPipelineArtifact@1
            displayName: 'Publish Python Dependency Scan'
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)'
              artifactName: 'python-dependency-scan'
              publishLocation: 'pipeline'
            condition: succeededOrFailed()

  # ============================================================================
  # Stage 3: Container Image Scanning
  # ============================================================================
  - stage: ContainerScan
    displayName: 'Container Image Scanning'
    jobs:
      - job: TrivyScan
        displayName: 'Trivy Container Scan'
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          matrix:
            web:
              serviceName: 'web'
            authService:
              serviceName: 'auth-service'
            jobService:
              serviceName: 'job-service'
            resumeService:
              serviceName: 'resume-service'
            userService:
              serviceName: 'user-service'
            aiService:
              serviceName: 'ai-service'
        steps:
          - checkout: self

          - task: Docker@2
            displayName: 'Login to ACR'
            inputs:
              command: 'login'
              containerRegistry: '$(containerRegistry)'

          - task: Bash@3
            displayName: 'Install Trivy'
            inputs:
              targetType: 'inline'
              script: |
                wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
                echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
                sudo apt-get update
                sudo apt-get install trivy -y

          - task: Bash@3
            displayName: 'Pull Latest Image'
            inputs:
              targetType: 'inline'
              script: |
                docker pull $(containerRegistryUrl)/applyforus-$(serviceName):latest || echo "Image not found, will scan Dockerfile"

          - task: Bash@3
            displayName: 'Scan Image with Trivy'
            inputs:
              targetType: 'inline'
              script: |
                mkdir -p $(Build.ArtifactStagingDirectory)/trivy-scans

                echo "Scanning applyforus-$(serviceName)..."

                # Scan image if it exists
                if docker image inspect $(containerRegistryUrl)/applyforus-$(serviceName):latest &>/dev/null; then
                  trivy image \
                    --severity HIGH,CRITICAL \
                    --format json \
                    --output $(Build.ArtifactStagingDirectory)/trivy-scans/$(serviceName).json \
                    $(containerRegistryUrl)/applyforus-$(serviceName):latest

                  trivy image \
                    --severity HIGH,CRITICAL \
                    --format table \
                    $(containerRegistryUrl)/applyforus-$(serviceName):latest \
                    > $(Build.ArtifactStagingDirectory)/trivy-scans/$(serviceName).txt

                  # Check for vulnerabilities
                  VULN_COUNT=$(jq '.Results[]?.Vulnerabilities // [] | length' $(Build.ArtifactStagingDirectory)/trivy-scans/$(serviceName).json | awk '{s+=$1} END {print s}')

                  echo "Vulnerabilities found: $VULN_COUNT"

                  if [ "$VULN_COUNT" -gt "0" ]; then
                    echo "##vso[task.logissue type=warning]Vulnerabilities found in $(serviceName) image"
                  fi
                fi

          - task: PublishPipelineArtifact@1
            displayName: 'Publish Trivy Scan Results'
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)/trivy-scans'
              artifactName: 'trivy-scan-$(serviceName)'
              publishLocation: 'pipeline'
            condition: succeededOrFailed()

      - job: DockerfileScan
        displayName: 'Dockerfile Security Scan'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: Bash@3
            displayName: 'Install hadolint'
            inputs:
              targetType: 'inline'
              script: |
                wget -O /usr/local/bin/hadolint https://github.com/hadolint/hadolint/releases/download/v2.12.0/hadolint-Linux-x86_64
                chmod +x /usr/local/bin/hadolint

          - task: Bash@3
            displayName: 'Scan Dockerfiles'
            inputs:
              targetType: 'inline'
              workingDirectory: '$(scanWorkingDirectory)'
              script: |
                mkdir -p $(Build.ArtifactStagingDirectory)/dockerfile-scans

                echo "Scanning Dockerfiles..."

                find . -name "Dockerfile*" -type f | while read dockerfile; do
                  echo "Scanning $dockerfile"

                  SAFE_NAME=$(echo "$dockerfile" | sed 's/[^a-zA-Z0-9]/-/g')

                  hadolint "$dockerfile" \
                    --format json \
                    > $(Build.ArtifactStagingDirectory)/dockerfile-scans/${SAFE_NAME}.json || true

                  hadolint "$dockerfile" \
                    > $(Build.ArtifactStagingDirectory)/dockerfile-scans/${SAFE_NAME}.txt || true
                done

                echo "Dockerfile scanning completed"

          - task: PublishPipelineArtifact@1
            displayName: 'Publish Dockerfile Scan Results'
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)/dockerfile-scans'
              artifactName: 'dockerfile-scan-results'
              publishLocation: 'pipeline'

  # ============================================================================
  # Stage 4: Infrastructure Security
  # ============================================================================
  - stage: InfrastructureSecurity
    displayName: 'Infrastructure Security Scanning'
    jobs:
      - job: TerraformScan
        displayName: 'Terraform Security Scan'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: Bash@3
            displayName: 'Install tfsec'
            inputs:
              targetType: 'inline'
              script: |
                wget -O /usr/local/bin/tfsec https://github.com/aquasecurity/tfsec/releases/download/v1.28.1/tfsec-linux-amd64
                chmod +x /usr/local/bin/tfsec

          - task: Bash@3
            displayName: 'Scan Terraform Code'
            inputs:
              targetType: 'inline'
              workingDirectory: '$(scanWorkingDirectory)/infrastructure/terraform'
              script: |
                echo "Scanning Terraform code..."

                tfsec . \
                  --format json \
                  --out $(Build.ArtifactStagingDirectory)/tfsec-results.json || true

                tfsec . \
                  --format default \
                  > $(Build.ArtifactStagingDirectory)/tfsec-results.txt || true

                # Check for critical issues
                if [ -f "$(Build.ArtifactStagingDirectory)/tfsec-results.json" ]; then
                  CRITICAL_COUNT=$(jq '[.results[] | select(.severity == "CRITICAL")] | length' $(Build.ArtifactStagingDirectory)/tfsec-results.json)

                  echo "Critical issues found: $CRITICAL_COUNT"

                  if [ "$CRITICAL_COUNT" -gt "0" ] && [ "$(failOnCriticalSeverity)" = "true" ]; then
                    echo "##vso[task.logissue type=error]Critical issues found in Terraform code!"
                    exit 1
                  fi
                fi

          - task: PublishPipelineArtifact@1
            displayName: 'Publish Terraform Scan Results'
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)'
              artifactName: 'terraform-security-scan'
              publishLocation: 'pipeline'

      - job: KubernetesScan
        displayName: 'Kubernetes Manifest Scan'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: Bash@3
            displayName: 'Install kubesec'
            inputs:
              targetType: 'inline'
              script: |
                wget -O /usr/local/bin/kubesec https://github.com/controlplaneio/kubesec/releases/download/v2.13.0/kubesec_linux_amd64
                chmod +x /usr/local/bin/kubesec

          - task: Bash@3
            displayName: 'Scan Kubernetes Manifests'
            inputs:
              targetType: 'inline'
              workingDirectory: '$(scanWorkingDirectory)/infrastructure/kubernetes'
              script: |
                mkdir -p $(Build.ArtifactStagingDirectory)/kubernetes-scans

                echo "Scanning Kubernetes manifests..."

                find . -name "*.yaml" -o -name "*.yml" | while read manifest; do
                  echo "Scanning $manifest"

                  SAFE_NAME=$(echo "$manifest" | sed 's/[^a-zA-Z0-9]/-/g')

                  kubesec scan "$manifest" \
                    > $(Build.ArtifactStagingDirectory)/kubernetes-scans/${SAFE_NAME}.json || true
                done

                echo "Kubernetes manifest scanning completed"

          - task: PublishPipelineArtifact@1
            displayName: 'Publish Kubernetes Scan Results'
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)/kubernetes-scans'
              artifactName: 'kubernetes-security-scan'
              publishLocation: 'pipeline'

  # ============================================================================
  # Stage 5: Compliance and Reporting
  # ============================================================================
  - stage: ComplianceReporting
    displayName: 'Compliance and Reporting'
    dependsOn:
      - CodeSecurityScan
      - DependencyScan
      - ContainerScan
      - InfrastructureSecurity
    condition: succeededOrFailed()
    jobs:
      - job: GenerateReport
        displayName: 'Generate Security Report'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: DownloadPipelineArtifact@2
            displayName: 'Download All Scan Results'
            inputs:
              buildType: 'current'
              targetPath: '$(Pipeline.Workspace)/scan-results'
            continueOnError: true

          - task: Bash@3
            displayName: 'Generate Comprehensive Security Report'
            inputs:
              targetType: 'inline'
              script: |
                cat > $(Build.ArtifactStagingDirectory)/security-report.md << EOF
                # ApplyforUs Platform - Security Scan Report

                **Scan Date:** $(date)
                **Build ID:** $(Build.BuildId)
                **Branch:** $(Build.SourceBranchName)
                **Commit:** $(Build.SourceVersion)

                ## Executive Summary

                This report contains the results of comprehensive security scanning performed on the ApplyforUs platform.

                ## Scan Coverage

                ### Code Security
                - ✓ Secret Detection (TruffleHog, detect-secrets)
                - ✓ Static Application Security Testing (Semgrep)
                - ✓ License Compliance

                ### Dependencies
                - ✓ NPM Package Vulnerabilities
                - ✓ Python Package Vulnerabilities

                ### Container Security
                - ✓ Container Image Scanning (Trivy)
                - ✓ Dockerfile Best Practices (hadolint)

                ### Infrastructure Security
                - ✓ Terraform Security (tfsec)
                - ✓ Kubernetes Manifest Security (kubesec)

                ## Findings Summary

                Detailed findings are available in the pipeline artifacts.

                ## Recommendations

                1. **Immediate Actions**
                   - Review and remediate all critical severity issues
                   - Rotate any exposed secrets immediately
                   - Update dependencies with known vulnerabilities

                2. **Short-term Actions**
                   - Address high severity vulnerabilities
                   - Improve Dockerfile security configurations
                   - Strengthen Kubernetes security policies

                3. **Long-term Actions**
                   - Implement automated dependency updates
                   - Establish security baseline standards
                   - Regular security training for development team

                ## Compliance Status

                - **OWASP Top 10:** Scanning completed
                - **CIS Benchmarks:** Infrastructure scanned
                - **License Compliance:** Verified

                ## Next Steps

                1. Review all scan artifacts in Azure DevOps
                2. Create work items for identified vulnerabilities
                3. Schedule security review meeting
                4. Update security documentation

                ---
                **Generated by ApplyforUs Security Pipeline**
                EOF

                cat $(Build.ArtifactStagingDirectory)/security-report.md

          - task: PublishPipelineArtifact@1
            displayName: 'Publish Security Report'
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)/security-report.md'
              artifactName: 'security-report'
              publishLocation: 'pipeline'

          - task: Bash@3
            displayName: 'Send Notification'
            inputs:
              targetType: 'inline'
              script: |
                echo "Security scan completed"
                echo "Review the security report artifact for detailed findings"
                echo "Build URL: $(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
