name: Self-Healing Agent

on:
  schedule:
    - cron: '*/30 * * * *'  # Every 30 minutes
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to check/heal'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - dev
          - staging
          - prod
      action:
        description: 'Action to perform'
        required: true
        default: 'check'
        type: choice
        options:
          - check
          - heal
          - force-restart

concurrency:
  group: self-healing-${{ github.event.inputs.environment || 'all' }}
  cancel-in-progress: false

env:
  HEALTH_CHECK_TIMEOUT: 30
  MAX_RESTART_ATTEMPTS: 3
  POD_RESTART_THRESHOLD: 5

jobs:
  check-infrastructure:
    name: Check Infrastructure Health
    runs-on: ubuntu-latest
    outputs:
      dev_healthy: ${{ steps.check-dev.outputs.healthy }}
      staging_healthy: ${{ steps.check-staging.outputs.healthy }}
      prod_healthy: ${{ steps.check-prod.outputs.healthy }}
      issues_found: ${{ steps.summary.outputs.issues_found }}
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Check Dev Environment
        id: check-dev
        if: github.event.inputs.environment == 'all' || github.event.inputs.environment == 'dev' || github.event.inputs.environment == ''
        run: |
          echo "Checking dev environment..."

          # Check AKS cluster
          az aks show \
            --resource-group applyforus-dev-rg \
            --name applyforus-dev-aks \
            --query "powerState.code" -o tsv 2>/dev/null || echo "not-found"

          # Check web health
          DEV_HEALTH=$(curl -sf --max-time ${{ env.HEALTH_CHECK_TIMEOUT }} "https://dev.applyforus.com/health" && echo "ok" || echo "failed")

          if [ "$DEV_HEALTH" = "ok" ]; then
            echo "healthy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Dev environment is healthy"
          else
            echo "healthy=false" >> $GITHUB_OUTPUT
            echo "::warning::Dev environment health check failed"
          fi

      - name: Check Staging Environment
        id: check-staging
        if: github.event.inputs.environment == 'all' || github.event.inputs.environment == 'staging' || github.event.inputs.environment == ''
        run: |
          echo "Checking staging environment..."

          STAGING_HEALTH=$(curl -sf --max-time ${{ env.HEALTH_CHECK_TIMEOUT }} "https://staging.applyforus.com/health" && echo "ok" || echo "failed")

          if [ "$STAGING_HEALTH" = "ok" ]; then
            echo "healthy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Staging environment is healthy"
          else
            echo "healthy=false" >> $GITHUB_OUTPUT
            echo "::warning::Staging environment health check failed"
          fi

      - name: Check Production Environment
        id: check-prod
        if: github.event.inputs.environment == 'all' || github.event.inputs.environment == 'prod' || github.event.inputs.environment == ''
        run: |
          echo "Checking production environment..."

          PROD_HEALTH=$(curl -sf --max-time ${{ env.HEALTH_CHECK_TIMEOUT }} "https://applyforus.com/health" && echo "ok" || echo "failed")
          PROD_API=$(curl -sf --max-time ${{ env.HEALTH_CHECK_TIMEOUT }} "https://api.applyforus.com/health" && echo "ok" || echo "failed")

          if [ "$PROD_HEALTH" = "ok" ] && [ "$PROD_API" = "ok" ]; then
            echo "healthy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Production environment is healthy"
          else
            echo "healthy=false" >> $GITHUB_OUTPUT
            echo "::error::Production environment health check failed"
          fi

      - name: Summary
        id: summary
        run: |
          ISSUES=0
          if [ "${{ steps.check-dev.outputs.healthy }}" = "false" ]; then ISSUES=$((ISSUES+1)); fi
          if [ "${{ steps.check-staging.outputs.healthy }}" = "false" ]; then ISSUES=$((ISSUES+1)); fi
          if [ "${{ steps.check-prod.outputs.healthy }}" = "false" ]; then ISSUES=$((ISSUES+1)); fi

          echo "issues_found=$ISSUES" >> $GITHUB_OUTPUT

          if [ $ISSUES -gt 0 ]; then
            echo "::warning::Found $ISSUES environment(s) with issues"
          fi

  check-pods:
    name: Check Pod Health
    runs-on: ubuntu-latest
    needs: check-infrastructure
    outputs:
      unhealthy_pods: ${{ steps.analyze.outputs.unhealthy_pods }}
      crash_loops: ${{ steps.analyze.outputs.crash_loops }}
    strategy:
      fail-fast: false
      matrix:
        environment: [dev, staging, prod]
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS context
        uses: azure/aks-set-context@v3
        with:
          resource-group: applyforus-${{ matrix.environment }}-rg
          cluster-name: applyforus-${{ matrix.environment }}-aks
        continue-on-error: true

      - name: Check pod status
        id: pods
        run: |
          NAMESPACE="applyforus"
          if [ "${{ matrix.environment }}" != "prod" ]; then
            NAMESPACE="applyforus-${{ matrix.environment }}"
          fi

          echo "Checking pods in $NAMESPACE..."

          # Get pod status
          kubectl get pods -n $NAMESPACE -o json > pods.json 2>/dev/null || echo '{"items":[]}' > pods.json

          # Count unhealthy pods
          UNHEALTHY=$(jq '[.items[] | select(.status.phase != "Running" and .status.phase != "Succeeded")] | length' pods.json)
          echo "unhealthy=$UNHEALTHY" >> $GITHUB_OUTPUT

          # Check for crash loops
          CRASH_LOOPS=$(jq '[.items[] | select(.status.containerStatuses[]?.restartCount > ${{ env.POD_RESTART_THRESHOLD }})] | length' pods.json)
          echo "crash_loops=$CRASH_LOOPS" >> $GITHUB_OUTPUT

          # List problematic pods
          if [ "$UNHEALTHY" -gt 0 ] || [ "$CRASH_LOOPS" -gt 0 ]; then
            echo "### Problematic Pods in ${{ matrix.environment }}" >> $GITHUB_STEP_SUMMARY
            jq -r '.items[] | select(.status.phase != "Running" and .status.phase != "Succeeded") | "\(.metadata.name): \(.status.phase)"' pods.json >> $GITHUB_STEP_SUMMARY
            jq -r '.items[] | select(.status.containerStatuses[]?.restartCount > ${{ env.POD_RESTART_THRESHOLD }}) | "\(.metadata.name): \(.status.containerStatuses[].restartCount) restarts"' pods.json >> $GITHUB_STEP_SUMMARY
          fi
        continue-on-error: true

      - name: Analyze results
        id: analyze
        run: |
          echo "unhealthy_pods=${{ steps.pods.outputs.unhealthy || 0 }}" >> $GITHUB_OUTPUT
          echo "crash_loops=${{ steps.pods.outputs.crash_loops || 0 }}" >> $GITHUB_OUTPUT

  heal-pods:
    name: Heal Unhealthy Pods
    runs-on: ubuntu-latest
    needs: [check-infrastructure, check-pods]
    if: (github.event.inputs.action == 'heal' || github.event.inputs.action == 'force-restart') && needs.check-infrastructure.outputs.issues_found != '0'
    strategy:
      fail-fast: false
      matrix:
        environment: [dev, staging, prod]
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS context
        uses: azure/aks-set-context@v3
        with:
          resource-group: applyforus-${{ matrix.environment }}-rg
          cluster-name: applyforus-${{ matrix.environment }}-aks
        continue-on-error: true

      - name: Heal pods
        run: |
          NAMESPACE="applyforus"
          if [ "${{ matrix.environment }}" != "prod" ]; then
            NAMESPACE="applyforus-${{ matrix.environment }}"
          fi

          echo "Attempting to heal pods in $NAMESPACE..."

          # Delete stuck pods
          kubectl delete pods --field-selector=status.phase=Failed -n $NAMESPACE 2>/dev/null || true
          kubectl delete pods --field-selector=status.phase=Unknown -n $NAMESPACE 2>/dev/null || true

          # Restart pods with high restart counts
          CRASH_LOOP_PODS=$(kubectl get pods -n $NAMESPACE -o json | jq -r '.items[] | select(.status.containerStatuses[]?.restartCount > ${{ env.POD_RESTART_THRESHOLD }}) | .metadata.name')

          for pod in $CRASH_LOOP_PODS; do
            echo "Deleting crash-looping pod: $pod"
            kubectl delete pod $pod -n $NAMESPACE --grace-period=30 2>/dev/null || true
          done

          # Force restart if requested
          if [ "${{ github.event.inputs.action }}" = "force-restart" ]; then
            echo "Force restarting all deployments..."
            kubectl rollout restart deployment -n $NAMESPACE
          fi

          echo "Healing actions completed for ${{ matrix.environment }}"
        continue-on-error: true

      - name: Verify healing
        run: |
          NAMESPACE="applyforus"
          if [ "${{ matrix.environment }}" != "prod" ]; then
            NAMESPACE="applyforus-${{ matrix.environment }}"
          fi

          echo "Waiting for pods to stabilize..."
          sleep 60

          # Check pod status after healing
          kubectl get pods -n $NAMESPACE

          # Wait for rollouts if any were triggered
          for deployment in $(kubectl get deployments -n $NAMESPACE -o jsonpath='{.items[*].metadata.name}'); do
            kubectl rollout status deployment/$deployment -n $NAMESPACE --timeout=300s 2>/dev/null || true
          done
        continue-on-error: true

  check-services:
    name: Check Service Endpoints
    runs-on: ubuntu-latest
    needs: check-infrastructure
    outputs:
      failed_services: ${{ steps.check.outputs.failed_services }}
    steps:
      - name: Check service health endpoints
        id: check
        run: |
          FAILED=""

          # Production services
          SERVICES=(
            "https://applyforus.com/health:web"
            "https://api.applyforus.com/health:api"
            "https://api.applyforus.com/auth/health:auth"
            "https://api.applyforus.com/jobs/health:jobs"
            "https://api.applyforus.com/users/health:users"
          )

          for entry in "${SERVICES[@]}"; do
            URL="${entry%:*}"
            NAME="${entry#*:}"

            if curl -sf --max-time 15 "$URL" > /dev/null 2>&1; then
              echo "‚úÖ $NAME is healthy"
            else
              echo "‚ùå $NAME is unhealthy"
              FAILED="$FAILED$NAME,"
            fi
          done

          echo "failed_services=${FAILED%,}" >> $GITHUB_OUTPUT

          if [ -n "$FAILED" ]; then
            echo "::warning::Failed services: $FAILED"
          fi

  heal-services:
    name: Heal Failed Services
    runs-on: ubuntu-latest
    needs: [check-services, heal-pods]
    if: always() && needs.check-services.outputs.failed_services != '' && github.event.inputs.action != 'check'
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS context (Production)
        uses: azure/aks-set-context@v3
        with:
          resource-group: applyforus-prod-rg
          cluster-name: applyforus-prod-aks

      - name: Restart failed services
        run: |
          FAILED="${{ needs.check-services.outputs.failed_services }}"
          NAMESPACE="applyforus"

          IFS=',' read -ra SERVICES <<< "$FAILED"
          for service in "${SERVICES[@]}"; do
            case $service in
              web)
                echo "Restarting web service..."
                kubectl rollout restart deployment/web -n $NAMESPACE
                ;;
              api|auth)
                echo "Restarting auth-service..."
                kubectl rollout restart deployment/auth-service -n $NAMESPACE
                ;;
              jobs)
                echo "Restarting job-service..."
                kubectl rollout restart deployment/job-service -n $NAMESPACE
                ;;
              users)
                echo "Restarting user-service..."
                kubectl rollout restart deployment/user-service -n $NAMESPACE
                ;;
            esac
          done

          # Wait for restarts
          sleep 30

          # Verify
          for service in "${SERVICES[@]}"; do
            case $service in
              web)
                kubectl rollout status deployment/web -n $NAMESPACE --timeout=300s || true
                ;;
              api|auth)
                kubectl rollout status deployment/auth-service -n $NAMESPACE --timeout=300s || true
                ;;
              jobs)
                kubectl rollout status deployment/job-service -n $NAMESPACE --timeout=300s || true
                ;;
              users)
                kubectl rollout status deployment/user-service -n $NAMESPACE --timeout=300s || true
                ;;
            esac
          done

  check-database:
    name: Check Database Connectivity
    runs-on: ubuntu-latest
    needs: check-infrastructure
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Check database status
        run: |
          # Check Azure Database for PostgreSQL status
          for env in dev staging prod; do
            STATUS=$(az postgres flexible-server show \
              --resource-group applyforus-$env-rg \
              --name applyforus-$env-db \
              --query "state" -o tsv 2>/dev/null || echo "not-found")

            if [ "$STATUS" = "Ready" ]; then
              echo "‚úÖ $env database is ready"
            else
              echo "::warning::$env database status: $STATUS"
            fi
          done
        continue-on-error: true

  check-redis:
    name: Check Redis Connectivity
    runs-on: ubuntu-latest
    needs: check-infrastructure
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Check Redis status
        run: |
          for env in dev staging prod; do
            STATUS=$(az redis show \
              --resource-group applyforus-$env-rg \
              --name applyforus-$env-redis \
              --query "provisioningState" -o tsv 2>/dev/null || echo "not-found")

            if [ "$STATUS" = "Succeeded" ]; then
              echo "‚úÖ $env Redis is healthy"
            else
              echo "::warning::$env Redis status: $STATUS"
            fi
          done
        continue-on-error: true

  generate-report:
    name: Generate Health Report
    runs-on: ubuntu-latest
    needs: [check-infrastructure, check-pods, check-services, check-database, check-redis]
    if: always()
    steps:
      - name: Create health report
        run: |
          echo "## Self-Healing Agent Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Environment Health" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Development | ${{ needs.check-infrastructure.outputs.dev_healthy == 'true' && '‚úÖ Healthy' || '‚ö†Ô∏è Issues' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Staging | ${{ needs.check-infrastructure.outputs.staging_healthy == 'true' && '‚úÖ Healthy' || '‚ö†Ô∏è Issues' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Production | ${{ needs.check-infrastructure.outputs.prod_healthy == 'true' && '‚úÖ Healthy' || '‚ö†Ô∏è Issues' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -n "${{ needs.check-services.outputs.failed_services }}" ]; then
            echo "### Failed Services" >> $GITHUB_STEP_SUMMARY
            echo "${{ needs.check-services.outputs.failed_services }}" >> $GITHUB_STEP_SUMMARY
          fi

  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [check-infrastructure, check-services, heal-pods, heal-services, generate-report]
    if: always() && (needs.check-infrastructure.outputs.issues_found != '0' || needs.check-services.outputs.failed_services != '')
    steps:
      - name: Notify Slack
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "üè• Self-Healing Agent Report",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "Self-Healing Agent Report"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Issues Found:*\n${{ needs.check-infrastructure.outputs.issues_found || '0' }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Action Taken:*\n${{ github.event.inputs.action || 'check' }}"
                    }
                  ]
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Dev:*\n${{ needs.check-infrastructure.outputs.dev_healthy == 'true' && '‚úÖ' || '‚ö†Ô∏è' }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Staging:*\n${{ needs.check-infrastructure.outputs.staging_healthy == 'true' && '‚úÖ' || '‚ö†Ô∏è' }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Production:*\n${{ needs.check-infrastructure.outputs.prod_healthy == 'true' && '‚úÖ' || '‚ö†Ô∏è' }}"
                    }
                  ]
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Report"
                      },
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    },
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "Trigger Healing"
                      },
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/workflows/self-healing.yml"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
