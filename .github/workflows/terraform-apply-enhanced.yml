name: Terraform Apply (Enhanced)

on:
  push:
    branches: [main]
    paths:
      - 'infrastructure/terraform/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
      auto_approve:
        description: 'Auto-approve apply (only for dev)'
        required: false
        type: boolean
        default: false

concurrency:
  group: terraform-apply-${{ github.event.inputs.environment || 'main' }}
  cancel-in-progress: false

env:
  TF_VERSION: '1.6.0'
  TF_WORKING_DIR: 'infrastructure/terraform'
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

jobs:
  determine-environment:
    name: Determine Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
    steps:
      - name: Set Environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi

  # GATE 1: Pre-flight validation checks
  pre-flight-checks:
    name: Pre-flight Validation
    runs-on: ubuntu-latest
    needs: determine-environment
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Validate Terraform syntax
        run: |
          cd ${{ env.TF_WORKING_DIR }}
          terraform fmt -check -recursive
          terraform init -backend=false
          terraform validate

      - name: Check for required files
        run: |
          ENV="${{ needs.determine-environment.outputs.environment }}"
          if [ ! -f "${{ env.TF_WORKING_DIR }}/environments/${ENV}.tfvars" ]; then
            echo "::error::Missing tfvars file for environment: $ENV"
            exit 1
          fi
          echo "All required files present"

  # GATE 2: Security and compliance scan
  security-gate:
    name: Security & Compliance Gate
    runs-on: ubuntu-latest
    needs: pre-flight-checks
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run tfsec
        uses: aquasecurity/tfsec-action@v1.0.3
        with:
          working_directory: ${{ env.TF_WORKING_DIR }}
          soft_fail: false
          additional_args: --minimum-severity HIGH

      - name: Run Checkov
        uses: bridgecrewio/checkov-action@v12
        with:
          directory: ${{ env.TF_WORKING_DIR }}
          framework: terraform
          soft_fail: false
          skip_check: CKV_AZURE_1,CKV_AZURE_2

  # GATE 3: Cost estimation and approval
  cost-estimation:
    name: Cost Estimation
    runs-on: ubuntu-latest
    needs: [determine-environment, security-gate]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ secrets.TF_STATE_RESOURCE_GROUP }}" \
            -backend-config="storage_account_name=${{ secrets.TF_STATE_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=${{ secrets.TF_STATE_CONTAINER }}" \
            -backend-config="key=applyforus-${{ needs.determine-environment.outputs.environment }}.tfstate"
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Plan
        run: |
          terraform plan \
            -var-file="environments/${{ needs.determine-environment.outputs.environment }}.tfvars" \
            -out=tfplan \
            -no-color 2>&1 | tee plan-output.txt
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Run Infracost
        uses: infracost/actions/setup@v2
        with:
          api-key: ${{ secrets.INFRACOST_API_KEY }}
        continue-on-error: true

      - name: Generate cost estimate
        if: secrets.INFRACOST_API_KEY != ''
        run: |
          infracost breakdown \
            --path ${{ env.TF_WORKING_DIR }}/tfplan \
            --format json \
            --out-file infracost.json

          infracost output \
            --path infracost.json \
            --format table \
            --out-file cost-summary.txt

          cat cost-summary.txt
          echo "### Cost Estimate" >> $GITHUB_STEP_SUMMARY
          cat cost-summary.txt >> $GITHUB_STEP_SUMMARY
        continue-on-error: true

      - name: Upload plan artifacts
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-${{ needs.determine-environment.outputs.environment }}
          path: |
            ${{ env.TF_WORKING_DIR }}/tfplan
            ${{ env.TF_WORKING_DIR }}/plan-output.txt
          retention-days: 30

  # GATE 4: Manual approval for staging and prod
  approval-gate-staging:
    name: Approval Required - Staging
    runs-on: ubuntu-latest
    needs: [determine-environment, cost-estimation]
    if: needs.determine-environment.outputs.environment == 'staging'
    environment:
      name: staging-terraform-approval
    steps:
      - name: Request approval
        run: |
          echo "::notice::Manual approval required for staging infrastructure changes"
          echo "Review the Terraform plan and cost estimate before approving"

  approval-gate-prod:
    name: Approval Required - Production
    runs-on: ubuntu-latest
    needs: [determine-environment, cost-estimation]
    if: needs.determine-environment.outputs.environment == 'prod'
    environment:
      name: production-terraform-approval
    steps:
      - name: Request approval
        run: |
          echo "::warning::CRITICAL: Manual approval required for PRODUCTION infrastructure changes"
          echo "Review the Terraform plan and cost estimate before approving"
          echo "Ensure backup and rollback plans are in place"

  apply-dev:
    name: Apply to Dev
    runs-on: ubuntu-latest
    needs: [determine-environment, cost-estimation]
    if: needs.determine-environment.outputs.environment == 'dev'
    environment: development
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Download plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan-dev
          path: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ secrets.TF_STATE_RESOURCE_GROUP }}" \
            -backend-config="storage_account_name=${{ secrets.TF_STATE_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=${{ secrets.TF_STATE_CONTAINER }}" \
            -backend-config="key=applyforus-dev.tfstate"
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Apply
        run: terraform apply -auto-approve tfplan
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Export Outputs
        id: outputs
        run: |
          echo "aks_cluster_name=$(terraform output -raw aks_cluster_name 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
          echo "acr_login_server=$(terraform output -raw acr_login_server 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
          echo "resource_group_name=$(terraform output -raw resource_group_name 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Verify AKS Connectivity
        if: steps.outputs.outputs.aks_cluster_name != ''
        run: |
          az aks get-credentials \
            --resource-group ${{ steps.outputs.outputs.resource_group_name }} \
            --name ${{ steps.outputs.outputs.aks_cluster_name }} \
            --overwrite-existing
          kubectl get nodes
          kubectl get namespaces

      - name: Post Apply Summary
        if: always()
        run: |
          echo "## Terraform Apply Summary - Dev" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | dev |" >> $GITHUB_STEP_SUMMARY
          echo "| AKS Cluster | ${{ steps.outputs.outputs.aks_cluster_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ACR Server | ${{ steps.outputs.outputs.acr_login_server }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Resource Group | ${{ steps.outputs.outputs.resource_group_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "*Applied at: $(date)*" >> $GITHUB_STEP_SUMMARY

  apply-staging:
    name: Apply to Staging
    runs-on: ubuntu-latest
    needs: [determine-environment, approval-gate-staging]
    if: needs.determine-environment.outputs.environment == 'staging'
    environment:
      name: staging
      url: https://staging.applyforus.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Download plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan-staging
          path: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ secrets.TF_STATE_RESOURCE_GROUP }}" \
            -backend-config="storage_account_name=${{ secrets.TF_STATE_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=${{ secrets.TF_STATE_CONTAINER }}" \
            -backend-config="key=applyforus-staging.tfstate"
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Apply
        run: terraform apply -auto-approve tfplan
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Export Outputs
        id: outputs
        run: |
          echo "aks_cluster_name=$(terraform output -raw aks_cluster_name 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
          echo "acr_login_server=$(terraform output -raw acr_login_server 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
          echo "resource_group_name=$(terraform output -raw resource_group_name 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Verify Staging Infrastructure
        if: steps.outputs.outputs.aks_cluster_name != ''
        run: |
          az aks get-credentials \
            --resource-group ${{ steps.outputs.outputs.resource_group_name }} \
            --name ${{ steps.outputs.outputs.aks_cluster_name }} \
            --overwrite-existing
          kubectl get nodes
          kubectl get namespaces
          kubectl get pods -n applyforus-staging || echo "Namespace not yet created"

  apply-prod:
    name: Apply to Production
    runs-on: ubuntu-latest
    needs: [determine-environment, approval-gate-prod]
    if: needs.determine-environment.outputs.environment == 'prod'
    environment:
      name: production
      url: https://applyforus.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Download plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan-prod
          path: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ secrets.TF_STATE_RESOURCE_GROUP }}" \
            -backend-config="storage_account_name=${{ secrets.TF_STATE_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=${{ secrets.TF_STATE_CONTAINER }}" \
            -backend-config="key=applyforus-prod.tfstate"
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Create state backup
        run: |
          terraform state pull > state-backup-$(date +%Y%m%d-%H%M%S).json
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Upload state backup
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state-backup-${{ github.sha }}
          path: ${{ env.TF_WORKING_DIR }}/state-backup-*.json
          retention-days: 90

      - name: Terraform Apply
        run: terraform apply -auto-approve tfplan
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Export Production Outputs
        id: outputs
        run: |
          echo "aks_cluster_name=$(terraform output -raw aks_cluster_name 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
          echo "acr_login_server=$(terraform output -raw acr_login_server 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
          echo "resource_group_name=$(terraform output -raw resource_group_name 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
          echo "key_vault_name=$(terraform output -raw key_vault_name 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
          echo "app_insights_key=$(terraform output -raw app_insights_instrumentation_key 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Verify Production Infrastructure
        if: steps.outputs.outputs.aks_cluster_name != ''
        run: |
          az aks get-credentials \
            --resource-group ${{ steps.outputs.outputs.resource_group_name }} \
            --name ${{ steps.outputs.outputs.aks_cluster_name }} \
            --overwrite-existing

          echo "### Node Status"
          kubectl get nodes

          echo "### Namespace Status"
          kubectl get namespaces

          echo "### Production Pods"
          kubectl get pods -n applyforus || echo "Namespace not yet created"

          echo "### Services"
          kubectl get services -n applyforus || echo "No services yet"

      - name: Production Apply Summary
        if: always()
        run: |
          echo "## Production Terraform Apply Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Infrastructure Details" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| AKS Cluster | ${{ steps.outputs.outputs.aks_cluster_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ACR Server | ${{ steps.outputs.outputs.acr_login_server }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Resource Group | ${{ steps.outputs.outputs.resource_group_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Key Vault | ${{ steps.outputs.outputs.key_vault_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "*Deployed by: @${{ github.actor }} at $(date)*" >> $GITHUB_STEP_SUMMARY

      - name: Notify Slack - Production Deploy
        if: always()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "${{ job.status == 'success' && '✅' || '❌' }} Production Infrastructure ${{ job.status }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Production Terraform Apply ${{ job.status }}*\n*Commit:* ${{ github.sha }}\n*Actor:* ${{ github.actor }}"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
