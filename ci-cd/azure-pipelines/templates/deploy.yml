# ==============================================================================
# Deployment Template
# ==============================================================================
# This template handles deployment to AKS (Azure Kubernetes Service)
# ==============================================================================

parameters:
  - name: environment
    type: string
    values:
      - dev
      - staging
      - production

  - name: azureSubscription
    type: string

  - name: aksResourceGroup
    type: string

  - name: aksClusterName
    type: string

  - name: namespace
    type: string

  - name: imageTag
    type: string

  - name: requireApproval
    type: boolean
    default: false

jobs:
  - deployment: Deploy${{ parameters.environment }}
    displayName: 'Deploy to ${{ parameters.environment }}'
    ${{ if eq(parameters.requireApproval, true) }}:
      environment: 'ApplyPlatform-${{ parameters.environment }}'
    pool:
      vmImage: 'ubuntu-latest'

    strategy:
      runOnce:
        deploy:
          steps:
            # Download image manifest
            - task: DownloadPipelineArtifact@2
              displayName: 'Download image manifest'
              inputs:
                artifactName: 'image-manifest'
                targetPath: '$(Pipeline.Workspace)/manifests'

            # Checkout Kubernetes manifests
            - checkout: self
              fetchDepth: 1

            # Install kubectl
            - task: KubectlInstaller@0
              displayName: 'Install kubectl'
              inputs:
                kubectlVersion: 'latest'

            # Get AKS credentials
            - task: AzureCLI@2
              displayName: 'Get AKS credentials'
              inputs:
                azureSubscription: '${{ parameters.azureSubscription }}'
                scriptType: 'bash'
                scriptLocation: 'inlineScript'
                inlineScript: |
                  az aks get-credentials \
                    --resource-group ${{ parameters.aksResourceGroup }} \
                    --name ${{ parameters.aksClusterName }} \
                    --overwrite-existing

            # Create namespace if not exists
            - task: Kubernetes@1
              displayName: 'Create namespace'
              continueOnError: true
              inputs:
                connectionType: 'Azure Resource Manager'
                azureSubscriptionEndpoint: '${{ parameters.azureSubscription }}'
                azureResourceGroup: '${{ parameters.aksResourceGroup }}'
                kubernetesCluster: '${{ parameters.aksClusterName }}'
                command: 'create'
                arguments: 'namespace ${{ parameters.namespace }}'

            # Apply Kubernetes secrets (from Azure Key Vault or Variable Groups)
            - task: KubernetesManifest@1
              displayName: 'Create secrets'
              inputs:
                action: 'createSecret'
                connectionType: 'azureResourceManager'
                azureSubscription: '${{ parameters.azureSubscription }}'
                azureResourceGroup: '${{ parameters.aksResourceGroup }}'
                kubernetesCluster: '${{ parameters.aksClusterName }}'
                namespace: '${{ parameters.namespace }}'
                secretType: 'generic'
                secretName: 'applyforus-secrets'
                secretArguments: |
                  --from-literal=DATABASE_URL=$(DATABASE_URL)
                  --from-literal=REDIS_URL=$(REDIS_URL)
                  --from-literal=JWT_SECRET=$(JWT_SECRET)
                  --from-literal=SENDGRID_API_KEY=$(SENDGRID_API_KEY)
                  --from-literal=OPENAI_API_KEY=$(OPENAI_API_KEY)

            # Update image tags in Kubernetes manifests
            - script: |
                IMAGE_TAG=${{ parameters.imageTag }}

                # Update web app
                sed -i "s|image:.*applyforus-web:.*|image: $(cat $(Pipeline.Workspace)/manifests/image-manifest.json | jq -r '.images.frontend.web')|g" \
                  infrastructure/kubernetes/services/web-app.yaml

                # Update auth service
                sed -i "s|image:.*applyforus-auth-service:.*|image: $(cat $(Pipeline.Workspace)/manifests/image-manifest.json | jq -r '.images.backend["auth-service"]')|g" \
                  infrastructure/kubernetes/services/auth-service.yaml

                # Update user service
                sed -i "s|image:.*applyforus-user-service:.*|image: $(cat $(Pipeline.Workspace)/manifests/image-manifest.json | jq -r '.images.backend["user-service"]')|g" \
                  infrastructure/kubernetes/services/user-service.yaml

                # Update job service
                sed -i "s|image:.*applyforus-job-service:.*|image: $(cat $(Pipeline.Workspace)/manifests/image-manifest.json | jq -r '.images.backend["job-service"]')|g" \
                  infrastructure/kubernetes/services/job-service.yaml

                # Update resume service
                sed -i "s|image:.*applyforus-resume-service:.*|image: $(cat $(Pipeline.Workspace)/manifests/image-manifest.json | jq -r '.images.backend["resume-service"]')|g" \
                  infrastructure/kubernetes/services/resume-service.yaml

                # Update notification service
                sed -i "s|image:.*applyforus-notification-service:.*|image: $(cat $(Pipeline.Workspace)/manifests/image-manifest.json | jq -r '.images.backend["notification-service"]')|g" \
                  infrastructure/kubernetes/services/notification-service.yaml

                # Update auto-apply service
                sed -i "s|image:.*applyforus-auto-apply-service:.*|image: $(cat $(Pipeline.Workspace)/manifests/image-manifest.json | jq -r '.images.backend["auto-apply-service"]')|g" \
                  infrastructure/kubernetes/services/auto-apply-service.yaml

                # Update analytics service
                sed -i "s|image:.*applyforus-analytics-service:.*|image: $(cat $(Pipeline.Workspace)/manifests/image-manifest.json | jq -r '.images.backend["analytics-service"]')|g" \
                  infrastructure/kubernetes/services/analytics-service.yaml

                # Update orchestrator service
                sed -i "s|image:.*applyforus-orchestrator-service:.*|image: $(cat $(Pipeline.Workspace)/manifests/image-manifest.json | jq -r '.images.backend["orchestrator-service"]')|g" \
                  infrastructure/kubernetes/services/orchestrator-service.yaml

                # Update AI service
                sed -i "s|image:.*applyforus-ai-service:.*|image: $(cat $(Pipeline.Workspace)/manifests/image-manifest.json | jq -r '.images.ai["ai-service"]')|g" \
                  infrastructure/kubernetes/services/ai-service.yaml

                echo "Updated all image tags to: $IMAGE_TAG"
              displayName: 'Update image tags in manifests'

            # Deploy to Kubernetes using Kustomize
            - task: KubernetesManifest@1
              displayName: 'Deploy to Kubernetes'
              inputs:
                action: 'deploy'
                connectionType: 'azureResourceManager'
                azureSubscription: '${{ parameters.azureSubscription }}'
                azureResourceGroup: '${{ parameters.aksResourceGroup }}'
                kubernetesCluster: '${{ parameters.aksClusterName }}'
                namespace: '${{ parameters.namespace }}'
                manifests: |
                  infrastructure/kubernetes/kustomization.yaml
                  infrastructure/kubernetes/services/*.yaml

            # Wait for deployment to stabilize
            - task: Kubernetes@1
              displayName: 'Wait for rollout'
              inputs:
                connectionType: 'Azure Resource Manager'
                azureSubscriptionEndpoint: '${{ parameters.azureSubscription }}'
                azureResourceGroup: '${{ parameters.aksResourceGroup }}'
                kubernetesCluster: '${{ parameters.aksClusterName }}'
                namespace: '${{ parameters.namespace }}'
                command: 'rollout'
                arguments: 'status deployment/web-app --timeout=5m'

            # Verify deployment health
            - script: |
                echo "Verifying deployment health..."

                # Check all deployments
                kubectl get deployments -n ${{ parameters.namespace }}

                # Check pods status
                kubectl get pods -n ${{ parameters.namespace }}

                # Check for any failed pods
                FAILED_PODS=$(kubectl get pods -n ${{ parameters.namespace }} --field-selector=status.phase!=Running,status.phase!=Succeeded --no-headers | wc -l)

                if [ $FAILED_PODS -gt 0 ]; then
                  echo "##vso[task.logissue type=warning]Found $FAILED_PODS pods not in Running/Succeeded state"
                  kubectl get pods -n ${{ parameters.namespace }} --field-selector=status.phase!=Running,status.phase!=Succeeded
                fi
              displayName: 'Verify deployment health'
              continueOnError: true

            # Run database migrations (if needed)
            - task: Kubernetes@1
              displayName: 'Run database migrations'
              condition: or(eq('${{ parameters.environment }}', 'dev'), eq('${{ parameters.environment }}', 'staging'))
              inputs:
                connectionType: 'Azure Resource Manager'
                azureSubscriptionEndpoint: '${{ parameters.azureSubscription }}'
                azureResourceGroup: '${{ parameters.aksResourceGroup }}'
                kubernetesCluster: '${{ parameters.aksClusterName }}'
                namespace: '${{ parameters.namespace }}'
                command: 'run'
                arguments: |
                  migration-job-$(Build.BuildId) \
                  --image=$(cat $(Pipeline.Workspace)/manifests/image-manifest.json | jq -r '.images.backend["user-service"]') \
                  --restart=Never \
                  --command -- pnpm run db:migrate

            # Health check
            - script: |
                echo "Running health checks..."

                # Get service endpoints
                kubectl get services -n ${{ parameters.namespace }}

                # Check if ingress is ready
                kubectl get ingress -n ${{ parameters.namespace }}

                echo "Deployment to ${{ parameters.environment }} completed successfully!"
              displayName: 'Post-deployment health check'

            # Generate deployment report
            - script: |
                cat > deployment-report.md << EOF
                # Deployment Report - ${{ parameters.environment }}

                ## Deployment Information
                - Environment: ${{ parameters.environment }}
                - Build ID: $(Build.BuildId)
                - Image Tag: ${{ parameters.imageTag }}
                - Namespace: ${{ parameters.namespace }}
                - AKS Cluster: ${{ parameters.aksClusterName }}
                - Deployment Time: $(date -u)

                ## Deployed Services
                $(kubectl get deployments -n ${{ parameters.namespace }} -o wide)

                ## Pods Status
                $(kubectl get pods -n ${{ parameters.namespace }} -o wide)

                ## Services
                $(kubectl get services -n ${{ parameters.namespace }} -o wide)

                ## Ingress
                $(kubectl get ingress -n ${{ parameters.namespace }} -o wide)

                EOF
                cat deployment-report.md
              displayName: 'Generate deployment report'

            # Publish deployment report
            - task: PublishPipelineArtifact@1
              displayName: 'Publish deployment report'
              inputs:
                targetPath: '$(Build.SourcesDirectory)/deployment-report.md'
                artifact: 'deployment-report-${{ parameters.environment }}'
                publishLocation: 'pipeline'

  # ============================================================================
  # Smoke Tests Job (runs after deployment)
  # ============================================================================
  - job: SmokeTests
    displayName: 'Run Smoke Tests'
    dependsOn: Deploy${{ parameters.environment }}
    pool:
      vmImage: 'ubuntu-latest'

    steps:
      # Checkout code
      - checkout: self
        fetchDepth: 1

      # Setup Node.js
      - task: NodeTool@0
        displayName: 'Setup Node.js'
        inputs:
          versionSpec: '20.x'

      # Get service URLs
      - task: AzureCLI@2
        displayName: 'Get service URLs'
        inputs:
          azureSubscription: '${{ parameters.azureSubscription }}'
          scriptType: 'bash'
          scriptLocation: 'inlineScript'
          inlineScript: |
            az aks get-credentials \
              --resource-group ${{ parameters.aksResourceGroup }} \
              --name ${{ parameters.aksClusterName }} \
              --overwrite-existing

            # Get ingress IP/hostname
            INGRESS_IP=$(kubectl get ingress -n ${{ parameters.namespace }} -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}')
            INGRESS_HOST=$(kubectl get ingress -n ${{ parameters.namespace }} -o jsonpath='{.items[0].spec.rules[0].host}')

            echo "##vso[task.setvariable variable=INGRESS_IP]$INGRESS_IP"
            echo "##vso[task.setvariable variable=INGRESS_HOST]$INGRESS_HOST"

            echo "Service URL: http://${INGRESS_HOST}"

      # Run smoke tests
      - script: |
          echo "Running smoke tests against: http://${INGRESS_HOST}"

          # Health check endpoints
          curl -f http://${INGRESS_HOST}/api/health || exit 1
          curl -f http://${INGRESS_HOST}/api/auth/health || exit 1
          curl -f http://${INGRESS_HOST}/api/users/health || exit 1
          curl -f http://${INGRESS_HOST}/api/jobs/health || exit 1

          echo "All smoke tests passed!"
        displayName: 'Execute smoke tests'
        continueOnError: true

      # Notify on failure
      - script: |
          if [ $? -ne 0 ]; then
            echo "##vso[task.logissue type=error]Smoke tests failed for ${{ parameters.environment }}"
            exit 1
          fi
        displayName: 'Check smoke test results'
        condition: failed()
