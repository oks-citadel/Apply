"""
Dependency injection for AI Service API endpoints.
"""

from typing import Optional, Annotated
import jwt
import structlog
from fastapi import Depends, HTTPException, Request, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

from ..config import settings
from ..services.llm_service import LLMService
from ..services.embedding_service import EmbeddingService
from ..services.vector_store import VectorStore
from ..models.job_matcher import JobMatcher
from ..models.resume_optimizer import ResumeOptimizer
from ..models.salary_predictor import SalaryPredictor

logger = structlog.get_logger()

# Security
security = HTTPBearer(auto_error=False)


# User Authentication Dependencies
class CurrentUser:
    """Current authenticated user information."""

    def __init__(self, user_id: str, email: str, roles: list[str]):
        """
        Initialize current user.

        Args:
            user_id: User ID
            email: User email
            roles: User roles
        """
        self.user_id = user_id
        self.email = email
        self.roles = roles

    def has_role(self, role: str) -> bool:
        """
        Check if user has a specific role.

        Args:
            role: Role to check

        Returns:
            True if user has the role
        """
        return role in self.roles


async def verify_jwt_token(token: str) -> dict:
    """
    Verify JWT token and extract payload.

    Args:
        token: JWT token string

    Returns:
        Token payload

    Raises:
        HTTPException: If token is invalid
    """
    try:
        # In production, fetch the secret from a secure location
        # For now, using a placeholder - should match auth service
        secret = "your-secret-key"  # TODO: Use proper secret management

        payload = jwt.decode(
            token,
            secret,
            algorithms=["HS256"],
            options={"verify_signature": False},  # TODO: Enable signature verification
        )

        return payload

    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token has expired",
            headers={"WWW-Authenticate": "Bearer"},
        )
    except jwt.InvalidTokenError as e:
        logger.warning(f"Invalid token: {e}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication token",
            headers={"WWW-Authenticate": "Bearer"},
        )


async def get_current_user(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(security),
) -> CurrentUser:
    """
    Get current authenticated user from JWT token.

    Args:
        credentials: HTTP authorization credentials

    Returns:
        Current user information

    Raises:
        HTTPException: If authentication fails
    """
    if not credentials:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication required",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # Verify token
    payload = await verify_jwt_token(credentials.credentials)

    # Extract user information
    user_id = payload.get("sub") or payload.get("user_id")
    email = payload.get("email")
    roles = payload.get("roles", [])

    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        )

    return CurrentUser(user_id=user_id, email=email, roles=roles)


async def get_current_user_optional(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(security),
) -> Optional[CurrentUser]:
    """
    Get current user if authenticated, otherwise return None.

    Args:
        credentials: HTTP authorization credentials

    Returns:
        Current user or None
    """
    if not credentials:
        return None

    try:
        return await get_current_user(credentials)
    except HTTPException:
        return None


# Service Dependencies
async def get_llm_service(request: Request) -> LLMService:
    """
    Get LLM service instance.

    Args:
        request: FastAPI request

    Returns:
        LLM service instance
    """
    return request.app.state.llm_service


async def get_embedding_service(request: Request) -> EmbeddingService:
    """
    Get embedding service instance.

    Args:
        request: FastAPI request

    Returns:
        Embedding service instance
    """
    return request.app.state.embedding_service


async def get_vector_store(request: Request) -> VectorStore:
    """
    Get vector store instance.

    Args:
        request: FastAPI request

    Returns:
        Vector store instance
    """
    return request.app.state.vector_store


async def get_job_matcher(request: Request) -> JobMatcher:
    """
    Get job matcher instance.

    Args:
        request: FastAPI request

    Returns:
        Job matcher instance
    """
    return request.app.state.job_matcher


async def get_resume_optimizer(request: Request) -> ResumeOptimizer:
    """
    Get resume optimizer instance.

    Args:
        request: FastAPI request

    Returns:
        Resume optimizer instance
    """
    return request.app.state.resume_optimizer


async def get_salary_predictor(request: Request) -> SalaryPredictor:
    """
    Get salary predictor instance.

    Args:
        request: FastAPI request

    Returns:
        Salary predictor instance
    """
    return request.app.state.salary_predictor


# Rate Limiting Dependencies
class RateLimiter:
    """Rate limiter for API endpoints."""

    def __init__(self, requests_per_minute: int = 60):
        """
        Initialize rate limiter.

        Args:
            requests_per_minute: Maximum requests per minute
        """
        self.requests_per_minute = requests_per_minute
        self.requests: dict[str, list[float]] = {}

    async def __call__(
        self,
        request: Request,
        user: Optional[CurrentUser] = Depends(get_current_user_optional),
    ):
        """
        Check rate limit for user or IP.

        Args:
            request: FastAPI request
            user: Current user if authenticated

        Raises:
            HTTPException: If rate limit exceeded
        """
        import time

        # Use user ID if authenticated, otherwise use IP
        identifier = user.user_id if user else (
            request.client.host if request.client else "unknown"
        )

        current_time = time.time()

        # Initialize request list
        if identifier not in self.requests:
            self.requests[identifier] = []

        # Clean old requests
        self.requests[identifier] = [
            req_time
            for req_time in self.requests[identifier]
            if current_time - req_time < 60
        ]

        # Check limit
        if len(self.requests[identifier]) >= self.requests_per_minute:
            logger.warning(
                "Rate limit exceeded",
                identifier=identifier,
                requests=len(self.requests[identifier]),
            )
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail=f"Rate limit exceeded. Maximum {self.requests_per_minute} requests per minute.",
            )

        # Add current request
        self.requests[identifier].append(current_time)


# Type aliases for dependency injection
LLMServiceDep = Annotated[LLMService, Depends(get_llm_service)]
EmbeddingServiceDep = Annotated[EmbeddingService, Depends(get_embedding_service)]
VectorStoreDep = Annotated[VectorStore, Depends(get_vector_store)]
JobMatcherDep = Annotated[JobMatcher, Depends(get_job_matcher)]
ResumeOptimizerDep = Annotated[ResumeOptimizer, Depends(get_resume_optimizer)]
SalaryPredictorDep = Annotated[SalaryPredictor, Depends(get_salary_predictor)]
CurrentUserDep = Annotated[CurrentUser, Depends(get_current_user)]
OptionalUserDep = Annotated[Optional[CurrentUser], Depends(get_current_user_optional)]

# Rate limiters for different tiers
standard_rate_limiter = RateLimiter(requests_per_minute=60)
premium_rate_limiter = RateLimiter(requests_per_minute=300)
